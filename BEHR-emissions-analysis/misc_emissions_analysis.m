classdef misc_emissions_analysis
    % This class is the core analysis code for Laughner and Cohen 2019. it
    % contains the functions necessary to generate the EMG fits and analyze
    % them. 
    %
    % Some common inputs across many of the methods here:
    %
    %   'loc_inds' - may be a numeric vector or (in some cases) a cell
    %   array of names indicating which locations to plot/analyze/etc. The
    %   numeric indices refer to the location index in the structure
    %   returned by read_locs_file. The names refer to the ShortName field
    %   in that same structure.
    %
    %   'file_loc_inds' - the location inds in a file name. This should
    %   pretty much always be 1:71 unless you've made new files for a
    %   subset of locations.
    %
    %   'time_periods' - which three year time period to use. Must be
    %   specified as a three-element vector, e.g. 2005:2007. Some older
    %   methods here expect a string such as 'beginning' or 'end', these
    %   functions should not be used.
    %
    %   'days_of_week' - specifies which days of week to use. Typically
    %   must be 'US' or 'TWRF'. The values come from single letter
    %   abbreviations for the days.
    %
    % Data directories (all under "Workspaces" in this directory):
    %
    %   SimpleAvgs - where the .mat files of NO2 and HCHO summertime VCD
    %   averages are stored. These are generated per year with
    %   make_summer_averages() then loaded for multi-year periods with 
    %   load_vcds_for_years(). 
    %
    %   SiteData - where the .mat files with just wind speed and direction
    %   information are stored, generated with make_location_winds_file().
    %   Also has the spreadsheet of basic location information.
    %
    %   LineDensities - where the .mat files containing the line densities
    %   are stored. These are created with make_rotated_line_densities().
    %
    %   EMGFits - where the .mat files containing the line densities and
    %   EMG fits are stored. These are created with make_emg_fits().
    %
    %   MOVES - contains .csv files generated by the EPA MOVES inventory
    %   with some post-processing.
    
    properties(Constant = true, Access = protected)
        % This is used to help check if all the required Git repos are in
        % the proper state. The first time any method calls the Git
        % verification method, if it passes, this is set to true so that it
        % doesn't need to be checked again.
        git_check_complete = false;
        
        % These define which field in the locations spreadsheet/structure
        % to use for which wind directions to reject
        wind_reject_field_std = 'WindRejects';
        wind_reject_field_wrf = 'WRFWindRejects';
        
        allowed_fit_types = {'lu','convolution'};
        
        % This is the standard fast/slow separation (in meters/second) used
        % if generating slow and fast line densities for the convolution
        % approach.
        fast_slow_sep = 3;
        
        dow_markers = struct('UMTWRFS', struct('marker', 'o', 'name', 'All days', 'used', false),...
            'TWRF', struct('marker', '^', 'name', 'Weekdays', 'used', false),...
            'US', struct('marker', 'h', 'name', 'Weekends', 'used', false));
            
        time_period_colors = struct('beg_2yr', struct('color', [0 0.5 0], 'name', '2006*', 'used', false),...
            'beginning', struct('color', 'b', 'name', '2008*', 'used', false),...
            'end_2yr', struct('color', [0.5 0 0.5], 'name', '2012-13', 'used', false),...
            'end', struct('color', 'r', 'name', '2013*', 'used', false),...
            'y2005', struct('color', 'r', 'name', '2005', 'used', false),...
            'y2006', struct('color', [1 0.5 0], 'name', '2006', 'used', false),...
            'y2007', struct('color', [0.5 0.5 0], 'name', '2007', 'used', false),...
            'y2008', struct('color', 'y', 'name', '2008', 'used', false),...
            'y2009', struct('color', 'g', 'name', '2009', 'used', false),...
            'y2010', struct('color', [0 0.5 0], 'name', '2010', 'used', false),...
            'y2011', struct('color', 'c', 'name', '2011', 'used', false),...
            'y2012', struct('color', 'b', 'name', '2012', 'used', false),...
            'y2013', struct('color', 'm', 'name', '2013', 'used', false),...
            'y2014', struct('color', [0.5 0 0.5], 'name', '2014', 'used', false));
    end
    
    methods(Static = true)
        %%%%%%%%%%%%%%%%%%%%%%%%%
        % Property like methods %
        %%%%%%%%%%%%%%%%%%%%%%%%%
        function value = workspace_dir()
            my_dir = fileparts(mfilename('fullpath'));
            value = fullfile(my_dir, 'Workspaces');
        end
        
        function value = avg_save_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'SimpleAvgs');
        end
        
        function value = site_info_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'SiteData');
        end
        
        function value = line_density_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'LineDensities');
        end
        
        function value = emg_fit_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'EMGFits');
        end
        
        function value = emis_wrf_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'WRFData');
        end
        
        function value = table_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'Tables');
        end
        
        function value = wrf_vcd_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'WRF-VCDs');
        end
        
        function filename = avg_file_name(year_in, days_of_week, varargin)
            p = advInputParser;
            p.addOptional('species', 'NO2');
            p.addParameter('season', 'summer');
            p.parse(varargin{:});
            pout = p.Results;
            species = lower(pout.species);
            season = capitalize_words(pout.season);
            
            years_str = strjoin(sprintfmulti('%d', year_in),'_');
            filename = sprintf('%s_avg_%s_%s_%s.mat', season, species, years_str, days_of_week);
            filename = fullfile(misc_emissions_analysis.avg_save_dir, filename);
        end
        
        function filename = winds_file_name(start_date, end_date)
            start_date = validate_date(start_date);
            end_date = validate_date(end_date);
            filename = sprintf('site_winds_%sto%s.mat', datestr(start_date(1), 'yyyy-mm-dd'), datestr(end_date(end), 'yyyy-mm-dd'));
            filename = fullfile(misc_emissions_analysis.site_info_dir, filename);
        end
        
        function filename = wrf_data_file_name(start_date, end_date)
            start_date = validate_date(start_date);
            end_date = validate_date(end_date);
            filename = sprintf('site_wrf_data_%sto%s.mat', datestr(start_date(1), 'yyyy-mm-dd'), datestr(end_date(end), 'yyyy-mm-dd'));
            filename = fullfile(misc_emissions_analysis.site_info_dir, filename);
        end
        
        function ind = nasa_wrf_int(use_wrf, use_nasa)
            if use_wrf && use_nasa
                error('use_wrf and use_nasa cannot both be true')
            elseif use_wrf
                ind = 1;
            elseif use_nasa
                ind = 2;
            else
                ind = 0;
            end
        end
        
        function filename = line_density_file_name(start_date, end_date, by_sectors, wind_reject_filtered, wind_dir_weighted, var_used, winds_op, winds_cutoff, loc_inds, days_of_week, wrf_var)
            if by_sectors
                sectors_string = 'sectors';
            else
                sectors_string = 'rotated';
            end
            
            if wind_reject_filtered
                filtered_string = 'filtered';
            else
                filtered_string = 'unfiltered';
            end
            
            if wind_dir_weighted
                weighted_string = 'weighted';
            else
                weighted_string = 'unweighted';
            end
            
            if var_used == 1
                if exist('wrf_var', 'var') && ~isempty(wrf_var)
                    data_string = sprintf('WRF_%s', upper(wrf_var));
                else
                    data_string = 'WRF';
                end
            elseif var_used == 2
                data_string = 'NASA';
            else
                data_string = 'BEHR';
            end
            
            
            allowed_winds_ops = {'lt', 'gt'};
            if ~ismember(winds_op, allowed_winds_ops)
                E.badinput('WINDS_OP must be one of %s', strjoin(allowed_winds_ops, ', '));
            end
            if ~isnumeric(winds_cutoff) || ~isscalar(winds_cutoff) || winds_cutoff < 0
                E.badinput('WINDS_CUTOFF must be a positive scalar integer')
            end
            winds_string = sprintf('winds-%s%d', winds_op, winds_cutoff);
            
            if isempty(loc_inds)
                locs_string = 'locsall';
            else
                locs_string = ['locs', sprintf_ranges(loc_inds)];
            end
            
            start_date = validate_date(start_date);
            end_date = validate_date(end_date);
            filename = sprintf('%s_%s_%s_%s_%s_%s_no2_%sto%s_%s.mat', data_string, sectors_string, filtered_string, weighted_string, winds_string, locs_string, datestr(start_date(1), 'yyyy-mm-dd'), datestr(end_date(end), 'yyyy-mm-dd'), days_of_week);
            filename = fullfile(misc_emissions_analysis.line_density_dir, filename);
        end
        
        function filename = behr_fit_file_name(time_period, days_of_week)
            % BEHR_FIT_FILE_NAME - returns the standard file for the BEHR
            % EMG fits for a time period (given as a numeric vector of
            % years) and the days of week ('TWRF', 'US', or 'UMTWRFS').
            % Wraps FITS_FILE_NAME and provides the default values for the
            % remaining inputs.
            start_date = datenum(min(time_period), 4, 1);
            end_date = datenum(max(time_period), 9, 30);
            filename = misc_emissions_analysis.fits_file_name(start_date, end_date, false, 1:71, days_of_week, 'lu');
        end
        
        function filename = nasa_fit_file_name(time_period, days_of_week)
            % NASA_FIT_FILE_NAME - returns the standard file for the NASA
            % EMG fits for a time period (given as a numeric vector of
            % years) and the days of week ('TWRF', 'US', or 'UMTWRFS').
            % Wraps FITS_FILE_NAME and provides the default values for the
            % remaining inputs.
            start_date = datenum(min(time_period), 4, 1);
            end_date = datenum(max(time_period), 9, 30);
            filename = misc_emissions_analysis.fits_file_name(start_date, end_date, 2, 1:71, days_of_week, 'lu');
        end
        
        function filename = wrf_fit_file_name(time_period, wrf_var, varargin)
            if nargin < 3
                dow = 'TWRF';
            else
                dow = varargin{1};
            end
            start_date = datenum(min(time_period), 4, 1);
            end_date = datenum(max(time_period), 9, 30);
            filename = misc_emissions_analysis.fits_file_name(start_date, end_date, true, 1:71, dow, 'lu', wrf_var);
        end
        
        function filename = fits_file_name(start_date, end_date, var_type, loc_inds, days_of_week, fit_type, wrf_var)
            if var_type == 1
                if ~exist('wrf_var', 'var')
                    product_string = 'WRF';
                else
                    product_string = sprintf('WRF_%s', upper(wrf_var));
                end
            elseif var_type == 2
                product_string = 'NASA';
            else
                product_string = 'BEHR';
            end
            
            if isempty(loc_inds)
                locs_string = 'locsall';
            else
                locs_string = ['locs', sprintf_ranges(loc_inds)];
            end
            
            
            start_date = validate_date(start_date);
            end_date = validate_date(end_date);
            filename = sprintf('%s_emg_%s_fits_%s_%sto%s_%s.mat', product_string, fit_type, locs_string, datestr(start_date(1), 'yyyy-mm-dd'), datestr(end_date(end), 'yyyy-mm-dd'), days_of_week);
            filename = fullfile(misc_emissions_analysis.emg_fit_dir, filename);
        end

        
        function filename = wrf_grid_area_file()
            filename = fullfile(misc_emissions_analysis.emis_wrf_dir, 'wrfgridarea_d01');
        end
        
        function filename = wrf_avg_prof_file(start_date, end_date)
            base_filename = sprintf('WRF_avg_profs_%s_to_%s.mat', datestr(start_date{1}, 'yyyy-mm-dd'), datestr(end_date{end}, 'yyyy-mm-dd'));
            filename = fullfile(misc_emissions_analysis.emis_wrf_dir, base_filename);
        end
        
        function value = debugging_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'Debugging');
        end
        
        function value = moves_dir
            value = misc_emissions_analysis.subdir_prep(misc_emissions_analysis.workspace_dir, 'MOVES');
        end
        
        function filename = moves_file(varargin)
            p = advInputParser;
            p.addOptional('domain','national');
            p.parse(varargin{:});
            pout = p.Results;
            domain = pout.domain;
            
            file = sprintf('moves_%s_2005to2014.csv', domain);
            filename = fullfile(misc_emissions_analysis.moves_dir, file);
        end
        
        function filename = county_shape_file()
            filename = fullfile(misc_emissions_analysis.site_info_dir, 'CountyShapes', 'cb_2017_us_county_500k.shp');
        end
        
        function fulldir = subdir_prep(root_dir, varargin)
            % Use this to setup sub-output directories. It will make sure
            % that the root directory exists (if not, it errors) and then
            % make the subdirectories if the don't exist
            E = JLLErrors;
            if ~exist(root_dir, 'dir')
                E.dir_dne(root_dir)
            end
            
            fulldir = fullfile(root_dir, varargin{:});
            if ~exist(fulldir, 'dir')
                mkdir(fulldir);
            end
        end
        
        
        %%%%%%%%%%%%%%%%%%%
        % Utility methods %
        %%%%%%%%%%%%%%%%%%%
        
        function verify_git_state()
            if ~misc_emissions_analysis.git_check_complete
                % This requires that validate_date and list_behr_files be able
                % to handle discontinuous date ranges and list_behr_files knows
                % about the 'all' flag.
                % Also requires that the sprintf_ranges and do_keep_day_of_week 
                % functions are available.
                G = GitChecker;
                G.addReqCommits(behr_paths.behr_utils, 'aad7763');
                G.addReqCommits(behr_paths.utils, 'fc1cef0');
                % checkState() by default will error if the repositories
                % are not in the correct state.
                G.checkState();
            end
        end
        
        function locs = read_locs_file(varargin)
            locs = read_loc_spreadsheet();
            if ~isempty(varargin)
                loc_types = {locs.SiteType};
                xx = ismember(loc_types, varargin);
                locs = locs(xx);
            end
        end
        
        function winds = load_winds_file(start_date, end_date)
            % Loads a winds file for a given start and end date and inserts
            % up-to-date box size and wind direction filtering from the
            % trend_locations.xlsx sheet.
            E = JLLErrors;
            
            start_date = validate_date(start_date);
            end_date = validate_date(end_date);
            
            winds_file = misc_emissions_analysis.winds_file_name(start_date, end_date);
            winds = load(winds_file);
            
            trend_locs = misc_emissions_analysis.read_locs_file();
            
            trend_shortnames = {trend_locs.ShortName};
            
            for a=1:numel(winds.locs)
                xx_loc = strcmp(winds.locs(a).ShortName, trend_shortnames);
                if sum(xx_loc) ~= 1
                    E.callError('location_not_found', 'Could not find location "%s" defined in the winds file %s but not the trend spreadsheet', winds.locs(a).ShortName, winds_file);
                end
                
                winds.locs(a).BoxSize = trend_locs(xx_loc).BoxSize;
                winds.locs(a).WindRejects = trend_locs(xx_loc).WindRejects;
            end
        end
        
        function dvec = make_datevec(start_date, end_date)
            % Create a date vector that enumerates all dates requested,
            % even if those are over non-continuous ranges.
            start_date = validate_date(start_date);
            end_date = validate_date(end_date);
            
            if numel(start_date) ~= numel(end_date)
                E.badinput('START_DATE and END_DATE must have equal numbers of elements')
            end
            
            dvec = [];
            for a=1:numel(start_date)
                dvec = veccat(dvec, start_date(a):end_date(a));
            end
        end
        
        function [start_dates, end_dates, time_period, legend_id] = select_start_end_dates(time_period, varargin)
            E = JLLErrors;
            % Returns the start and end dates as cell arrays of datenums.
            % TIME_PERIOD may be 'beginning', 'end', 'beg_2yr', or
            % 'end_2yr' specifying the standard start/end dates or a 2-by-N
            % cell array of dates, where the first row will be used as the
            % start dates and the second row as the end dates.
            p = advInputParser;
            p.addOptional('prompt', 'Which time period to use?');
            p.parse(varargin{:});
            pout = p.Results;
            
            prompt = pout.prompt;
            
            if nargin < 1 || isempty(time_period)
                avail_periods = 2006:2013;
                options_str = sprintfmulti('%d-%d', avail_periods-1, avail_periods+1);
                tp_ind = ask_multichoice(prompt, options_str, 'list', true, 'index', true);
                time_period = (avail_periods(tp_ind)-1):(avail_periods(tp_ind)+1);
            end
            
            start_month = 4;
            end_month = 9;
            
            if isnumeric(time_period)
                start_dates = cell(1,numel(time_period));
                end_dates = cell(1,numel(time_period));
                for i_yr = 1:numel(time_period)
                    start_dates{i_yr} = datenum(time_period(i_yr), start_month, 1);
                    end_dates{i_yr} = eomdate(time_period(i_yr), end_month);
                end
                legend_id = str2double(time_period);
            elseif ischar(time_period) || isstring(time_period)
                E.badinput('Giving the time period as a string is no longer supported.')
            elseif iscell(time_period)
                start_dates = validate_date(time_period(1,:));
                end_dates = validate_date(time_period(2,:));
            else
                E.badinput('TIME_PERIOD "%s" not recognized', time_period);
            end
        end
        
        function [dow, legend_id] = select_days_of_week(dow, varargin)
            p = advInputParser;
            p.addOptional('prompt', 'Select the days of week to use');
            p.parse(varargin{:});
            pout = p.Results;
            prompt = pout.prompt;
            dow = opt_ask_multichoice(prompt, {'UMTWRFS', 'TWRF', 'US'}, dow, 'days_of_week', 'list', true);
            
            legend_ids = struct('UMTWRFS', 'All', 'TWRF', 'Weekdays', 'US', 'Weekends');
            legend_id = legend_ids.(dow);
        end
        
        function inds = find_loc_struct_inds(locs)
            all_locs = misc_emissions_analysis.read_locs_file();
            all_locs_shortnames = {all_locs.ShortName};
            inds = nan(size(locs));
            for i_loc = 1:numel(locs)
                inds(i_loc) = find(strcmp(locs(i_loc).ShortName, all_locs_shortnames));
            end
        end
        
        function [xx, yy] = find_indicies_in_box_around_point(loc, lon, lat, radius)
            % LOC must be a scalar element of the locations structure, LON
            % and LAT must be 2D arrays of longitude and latitude
            % coordinates for an NO2 average or similar 2D field. RADIUS
            % must be a scalar number of grid cells in each direction to
            % get. If omitted, defaults to 0.
            E = JLLErrors;
            
            if ~exist('radius', 'var')
                radius = 0;
            end
             
            [xx, yy] = misc_emissions_analysis.find_lat_lon_index(loc.Longitude, loc.Latitude, lon, lat);
            
            xx = (xx - radius):(xx + radius);
            yy = (yy - radius):(yy + radius);
        end
        
        function [xx, radius] = find_indices_in_radius_around_loc(loc, lon, lat, varargin)
            % The Radius field is a carry over from Russell et al. 2012.
            % Now we use the boxes defined for the EMG fitting for
            % consistency. Alternately, you may specify your own radius, in
            % degrees
            p = advInputParser;
            p.addOptional('radius', []);
            p.addParameter('inner_rad', 0);
            p.parse(varargin{:});
            pout = p.Results;
            user_radius = pout.radius;
            inner_radius = pout.inner_rad;
            
            if isempty(user_radius)
                radius = mean(loc.BoxSize(3:4));
            else
                radius = user_radius;
            end
            r = sqrt((lon - loc.Longitude).^2 + (lat - loc.Latitude).^2);
            xx = r >= inner_radius & r < radius;
        end
        
        function [wrf_files, F] = closest_wrf_file_in_time(date_in, F)
            % Finds the WRF files closest in time to each swath in the BEHR
            % file for the DATE_IN. Returns the list of files as a cell
            % array. Can pass F in, which should be a structure returned
            % from DIRFF() of all relevant WRF files, which will speed up
            % this method.
            Data = load_behr_file(date_in, 'monthly', 'us'); % we only care about Time, which is the same in both monthly and daily products
            wrf_files = cell(size(Data));
            wrf_dir = find_wrf_path('us','daily',date_in);
            if ~exist('F','var')
                F = dirff(fullfile(wrf_dir, 'wrfout*'));
            end
            wrf_dates = date_from_wrf_filenames(F);
            for a=1:numel(Data)
                utc_datenum = omi_time_conv(nanmean(Data(a).Time(:)));
                [~, i_date] = min(abs(wrf_dates - utc_datenum));
                wrf_files{a} = F(i_date).name;
            end
        end
        
        function [lon, lat] = rotate_lon_lat(lon, lat, center_lon, center_lat, theta)
            R = [cosd(theta), -sind(theta); sind(theta), cosd(theta)];
            for a=1:numel(lon)
                rot_coords = R * [lon(a) - center_lon; lat(a) - center_lat];
                lon(a) = rot_coords(1) + center_lon;
                lat(a) = rot_coords(2) + center_lat;
            end
        end
        
        function wind_logical = set_wind_conditions(location, speed_cutoff, winds_op, wind_reject_field)
            E = JLLErrors;
            if ~isstruct(location) || ~isscalar(location) || any(~isfield(location, {'ShortName', 'WindDir', 'WindSpeed'}))
                E.badinput('LOCATION must be a scalar structure with fields "ShortName", "WindDir", and "WindSpeed"')
            end
            
            if ~isnumeric(speed_cutoff) || ~isscalar(speed_cutoff) || speed_cutoff < 0
                E.badinput('SPEED_CUTOFF must be a scalar, positive number')
            end
            
            allowed_fast_slow = {'lt', 'gt'};
            if ~ismember(winds_op, allowed_fast_slow)
                E.badinput('WINDS_OP must be one of: %s', strjoin(allowed_fast_slow));
            end
            
            if ~exist('wind_reject_field','var') || isempty(wind_reject_field)
                wind_reject_field = 'WindRejects';
            elseif ~ischar(wind_reject_field)
                E.badinput('WIND_REJECT_FIELD must be a character array');
            elseif ~isfield(location, wind_reject_field) && ~strcmpi(wind_reject_field, 'none')
                E.badinput('The WIND_REJECT_FIELD "%s" is not a field in LOCATION and is not the string "none"', wind_reject_field);
            end
            
            wind_logical = true(size(location.WindDir));
            
            % Use the wind direction ranges specified in the locations
            % structure to reject wind directions with downwind
            % interferences that will cause an issue with the
            % lifetime/emissions. The ranges are an N-by-2 array, the first
            % column specifies the beginning of the range, the second
            % column the end. However, since wind directions go from -180
            % to +180, we have to handle the "wrap-around" nature of
            % angular coordinates. To do so, when the first column is less
            % than the second we use the typical "&" operation, otherwise
            % we use "|" (or) since e.g. all angles between +170 and -170
            % would be >170 or <-170.
            if ~strcmpi(wind_reject_field, 'none')
                for a=1:size(location.(wind_reject_field),1)
                    wind_dir_range = location.(wind_reject_field)(a,:);
                    if wind_dir_range(1) < wind_dir_range(2)
                        xx = location.WindDir >= wind_dir_range(1) & location.WindDir < wind_dir_range(2);
                    else
                        xx = location.WindDir >= wind_dir_range(1) | location.WindDir < wind_dir_range(2);
                    end
                    
                    wind_logical(xx) = false;
                end
            end
            
            % Handle wind speed filtering here
            if strcmpi(winds_op, 'gt')
                wind_logical(location.WindSpeed < speed_cutoff) = false;
            elseif strcmpi(winds_op, 'lt')
                wind_logical(location.WindSpeed >= speed_cutoff) = false;
            else
                E.notimplemented('WINDS_OP = %s is not implemented', winds_op);
            end
        end
        
        function emis_tau = calculate_emission_lifetime(line_dens_struct, fit_struct, wind_speed_vector)
            % First we need to compute the total uncertainty in the
            % parameters that accounts for uncertainty in the NO2 VCDs,
            % across wind integration distance, choice of wind fields, etc.
            param_uncert = calc_fit_param_uncert(fit_struct.ffit, fit_struct.param_stats.percent_ci95/100, line_dens_struct.num_valid_obs);
            
            % Then use these uncertainties to calculate the emissions and
            % lifetime and their uncertainties
            emissions_type = 'no';
            [emis_tau.emis, emis_tau.emis_uncert, emis_tau.tau, emis_tau.tau_uncert] = compute_emg_emis_tau(fit_struct.ffit.a, param_uncert(1), fit_struct.ffit.x_0, param_uncert(2), 'vec', wind_speed_vector, 'emissions_type', emissions_type);
            
            % Calculate emission and lifetime standard deviations and
            % degrees of freedom because they are needed for the two-sample
            % t-tests.
            
            param_sd = calc_fit_param_uncert(fit_struct.ffit, fit_struct.param_stats.percentsd/100, line_dens_struct.num_valid_obs);
            [~, emis_tau.emis_sd, ~, emis_tau.tau_sd] = compute_emg_emis_tau(fit_struct.ffit.a, param_sd(1), fit_struct.ffit.x_0, param_sd(2), 'vec', wind_speed_vector, 'emissions_type', emissions_type);
            
            % In the fitting, we consider the number of measurements to be
            % the number of points in the line density. Since we are
            % fitting 5 parameters, we lose 5 degrees of freedom.
            emis_tau.n_dofs = sum(~isnan(line_dens_struct.linedens)) - 5;
        end
        
        function [total_nei_no, nei_lon, nei_lat] = load_nei_by_year(nei_year)
            
            E = JLLErrors;
            
            for a=1:numel(nei_year)
                % Make the input path
                tmp_path = find_wrf_path('us','daily',datenum(nei_year(a),1,1));
                path_parts = strsplit(tmp_path, '/');
                
                % The path on my computer is something like '/Volumes/share-wrfN/...'
                % and we just want to get which network drive it should be on.
                % The first three parts of the split path should be an empty
                % string, Volumes, and the share. This will put a / at the
                % beginning
                wrf_share = strjoin(path_parts(1:4), '/');
                
                % Whichever share it's on, it should be in a consistent path
                % there - except for 2012. I was having trouble getting the
                % full year's inputs to prepare, so I had to split it into two
                % 6 month periods. The NEI emissions are the same in both, so
                % we can just pick one.
                inputs_path = fullfile(wrf_share, 'Inputs', num2str(nei_year(a)), 'IC-BC-Emis');
                if nei_year(a) == 2012 || nei_year(a) == 2011
                    inputs_path = fullfile(inputs_path, 'Months01-06');
                elseif nei_year(a) == 2014
                    inputs_path = fullfile(inputs_path, 'Jan-Aug');
                end
                
                % We're going to average UTC 17-22, so we just need the second
                % 12 hr file
                nei_info = ncinfo(fullfile(inputs_path, 'wrfchemi_12z_d01'));
                input_info = ncinfo(fullfile(inputs_path, 'wrfinput_d01'));
                
                fprintf('Reading NEI data...\n');
                nei_lon = ncread(input_info.Filename, 'XLONG');
                nei_lat = ncread(input_info.Filename, 'XLAT');
                
                % Load the precalculated area - but double check that the
                % lat/lon matches the input
                area_lon = ncread(misc_emissions_analysis.wrf_grid_area_file, 'XLONG');
                area_lat = ncread(misc_emissions_analysis.wrf_grid_area_file, 'XLAT');
                if max(abs(area_lon(:) - nei_lon(:))) < 0.001 && max(abs(area_lat(:) - nei_lat(:))) < 0.001
                    grid_area = ncread(misc_emissions_analysis.wrf_grid_area_file, 'AREA');
                else
                    fprintf('Precomputed area lat/lon did not match, calculating WRF grid area...\n');
                    grid_area = wrf_grid_area(nei_lon, nei_lat);
                end
                
                nei_times = ncread(nei_info.Filename, 'Times')';
                nei_hours = hour(datenum(nei_times, 'yyyy-mm-dd_HH:MM:SS'));
                tt = nei_hours > 17 & nei_hours < 22;
                
                % Add up the emissions over the whole vertical extent; averaged
                % over 17:00 to 22:00 UTC, which is approximately the hours OMI
                % is over North America.
                nei_no = double(ncread(nei_info.Filename, 'E_NO'));
                nei_no = nansum(nanmean(nei_no(:,:,:,tt), 4), 3);
                
                % Not set up to handle NaNs 
                if any(isnan(nei_no(:))) || any(isnan(grid_area(:)))
                    E.notimplemented('Not set up to handle NaNs in NEI NO emissions or grid area');
                end
                
                % First time through the loop create the cumulative sum
                % array
                if a==1
                    total_nei_no = zeros(size(nei_no));
                end
                
                % Convert from mol NO / km^2 / hr to Mg NO / hr: molar mass of NO =
                % 30.006 g / mol = 30.006e-6 Mg / mol. Add to the running
                % sum, will normalize based on the number of years outside
                % the loop.
                total_nei_no = total_nei_no + nei_no .* grid_area .* 30.06e-6;
            end
            
            % To get the average NEI NO, we should be able to just divide
            % by the number of years that went into the calculation.
            total_nei_no = total_nei_no / numel(nei_year);
        end
        
        function fit = default_fit_structure()
            % Return a default structure skeleton for fitting information
            % to be used in cases where the fit fails but we want a
            % placeholder.
            null_value = [];
            fit.ffit = make_empty_struct_from_cell({'a','x_0','mu_x','sigma_x','B'},null_value);
            fit.emgfit = null_value;
            fit.param_stats = make_empty_struct_from_cell({'sd','percentsd','ci95','percent_ci95','r','r2'}, null_value);
            fit.f0 = null_value;
            fit.history.x = null_value;
            % Fit results is a complicated structure that I don't use, so
            % just make it an empty struct
            fit.fitresults = struct();
        end
        
        function emis_tau = default_emis_tau_structure()
            % Return a default structure skeleton for emissions and
            % lifetime information to be used in cases where the fit fails
            % but we want a placeholder.
            null_value = [];
            emis_tau = make_empty_struct_from_cell({'emis','emis_uncert','tau','tau_uncert','emis_sd','tau_sd','n_dofs','nei_emis'}, null_value);
        end
        
        function loc_inds = get_loc_inds_of_type(site_type)
            locs = misc_emissions_analysis.read_locs_file();
            loc_types = {locs.SiteType};
            
            if ~ischar(site_type)
                E.badinput('SITE_TYPE must be a character array')
            elseif strcmpi(site_type, 'all')
                loc_inds = 1:numel(locs);
                return
            elseif ~ismember(site_type, loc_types)
                E.badinput('SITE_TYPE is not a valid site type listed in the locations spreadsheet')
            end
            
            loc_inds = find(strcmp(site_type, loc_types));
        end
        
        function [loc_inds, file_loc_inds] = get_loc_inds_interactive(varargin)
            p = advInputParser;
            p.addFlag('one_loc');
            p.parse(varargin{:});
            pout = p.AdvResults;
            
            one_loc_flag = pout.one_loc;
            
            locs = misc_emissions_analysis.read_locs_file();
            loc_names = {locs.ShortName};
            loc_types = {locs.SiteType};
            loc_names = loc_names(~strcmpi(loc_types,'RuralAreas'));
            if ~one_loc_flag
                loc_inds = ask_multiselect('Choose the locations to use', loc_names, 'returnindex', true);
            else
                loc_inds = ask_multichoice('Choose the location to use', loc_names, 'returnindex', true);
            end
            
            min_ind = 1;
            max_ind = numel(loc_names);
            default_inds = 1:numel(loc_names);
            
            file_loc_inds = ask_number('Enter the location indicies in the file name', 'default', default_inds,...
                'testfxn', @(x) all(x >= min_ind & x <= max_ind), 'testmsg', sprintf('All values must be between %d and %d', min_ind, max_ind));
        end
        
        function [loc_inds, file_loc_inds] = convert_input_loc_inds(loc_inds)
            file_loc_inds = 1:71;
            if iscell(loc_inds)
                % must be in order for other functions to work
                loc_inds = sort(misc_emissions_analysis.loc_names_to_inds(loc_inds{:}));
            elseif isnan(loc_inds)
                [loc_inds, file_loc_inds] = misc_emissions_analysis.get_loc_inds_interactive();
            end
        end
        
        function fit_type_in = get_fit_type_interactive(varargin)
            if nargin > 0
                fit_type_in = varargin{1};
            else
                fit_type_in = '';
            end
            
            allowed_fit_types = misc_emissions_analysis.allowed_fit_types;
            if isempty(fit_type_in)
                fit_type_in = ask_multichoice('Which fitting method to use?', allowed_fit_types, 'list', true);
            elseif ~ismember(fit_type_in, allowed_fit_types)
                E.badinput('FIT_TYPE must be one of: %s', strjoin(allowed_fit_types, ', '));
            end
        end
        
        function ld_file = get_line_dens_file_interactive()
            avail_files = dir(fullfile(misc_emissions_analysis.line_density_dir, '*.mat'));
            avail_files = {avail_files.name};
            chosen_file = ask_multichoice('Choose the line density file to use', avail_files, 'list', true);
            ld_file = fullfile(misc_emissions_analysis.line_density_dir, chosen_file);
        end
        
        function [changes, loc_names, loc_coords] = collect_changes(first_time_period, second_time_period, first_weekdays, second_weekdays, varargin)
            E = JLLErrors;
            p = inputParser;
            p.addParameter('loc_inds', []);
            p.addParameter('include_vcds', true);
            p.addParameter('avg_radius', 'by_loc');
            p.addParameter('use_wrf', false);
            p.addParameter('file_loc_inds', 1:71); % location indicies in the file name
            p.addParameter('fit_type','');
            p.parse(varargin{:});
            pout = p.Results;
            
            user_loc_inds = pout.loc_inds;
            include_vcds = pout.include_vcds;
            avg_radius = pout.avg_radius;
            use_wrf = pout.use_wrf;
            file_loc_inds = pout.file_loc_inds;
            fit_type = misc_emissions_analysis.get_fit_type_interactive(pout.fit_type);
            
            [first_dates_st, first_dates_end] = misc_emissions_analysis.select_start_end_dates(first_time_period);
            [second_dates_st, second_dates_end] = misc_emissions_analysis.select_start_end_dates(second_time_period);
            
            first_file = misc_emissions_analysis.fits_file_name(first_dates_st(1), first_dates_end(end), use_wrf, file_loc_inds, first_weekdays, fit_type);
            fprintf('Loading %s\n', first_file);
            first_locs = load(first_file);
            second_file = misc_emissions_analysis.fits_file_name(second_dates_st(1), second_dates_end(end), use_wrf, file_loc_inds, second_weekdays, fit_type);
            fprintf('Loading %s\n', second_file);
            second_locs = load(second_file);
            
            first_locs.locs = misc_emissions_analysis.cutdown_locs_by_index(first_locs.locs, user_loc_inds, 'keep_order');
            second_locs.locs = misc_emissions_analysis.cutdown_locs_by_index(second_locs.locs, user_loc_inds, 'keep_order');
            loc_names = {first_locs.locs.Location};
            loc_coords.lon = [first_locs.locs.Longitude]';
            loc_coords.lat = [first_locs.locs.Latitude]';
            
            % Collect the emissions and lifetimes differences into two
            % n-by-2 arrays. Also get some metrics of the goodness of fit
            % and total mass
            
            additional_fns = {'r2','a','a_plus_B','is_fit_good'};
            emis_tau_fns = fieldnames(first_locs.locs(1).emis_tau);
            all_fns = veccat(emis_tau_fns, additional_fns, 'column');
            default_mat = nan(numel(first_locs.locs), 2);
            for i_fn = 1:numel(all_fns)
                changes.(all_fns{i_fn}) = default_mat;
                for i_loc = 1:numel(first_locs.locs)
                    if strcmpi(all_fns{i_fn}, 'a_plus_B')
                        first_value = a_plus_b(first_locs.locs(i_loc));
                        second_value = a_plus_b(second_locs.locs(i_loc));
                    elseif strcmpi(all_fns{i_fn}, 'is_fit_good')
                        first_value = misc_emissions_analysis.is_fit_good_by_loc(first_locs.locs(i_loc));
                        second_value = misc_emissions_analysis.is_fit_good_by_loc(second_locs.locs(i_loc));
                    else
                        first_value = find_substruct_field(first_locs.locs(i_loc), all_fns{i_fn});
                        second_value = find_substruct_field(second_locs.locs(i_loc), all_fns{i_fn});
                        
                        if isempty(first_value)
                            first_value = nan;
                        end
                        if isempty(second_value)
                            second_value = nan;
                        end
                    end
                    
                    changes.(all_fns{i_fn})(i_loc, :) = [first_value, second_value];
                end
            end
            
            changes.is_significant = misc_emissions_analysis.is_change_significant(changes.tau, changes.tau_sd, changes.n_dofs);
            
            if include_vcds
                changes.vcds = default_mat;
                changes.hcho_vcds = default_mat;
                if ~use_wrf
                    changes.vcds(:,1) = misc_emissions_analysis.avg_vcds_around_loc(first_locs.locs, first_time_period, first_weekdays, 'radius', avg_radius, 'ignore_missing_files', true);
                    changes.vcds(:,2) = misc_emissions_analysis.avg_vcds_around_loc(second_locs.locs, second_time_period, second_weekdays, 'radius', avg_radius, 'ignore_missing_files', true);
%                     changes.hcho_vcds(:,1) = misc_emissions_analysis.avg_vcds_around_loc(first_locs.locs, first_time_period, first_weekdays, 'radius', avg_radius, 'species', 'hcho');
%                     changes.hcho_vcds(:,2) = misc_emissions_analysis.avg_vcds_around_loc(second_locs.locs, second_time_period, second_weekdays, 'radius', avg_radius, 'species', 'hcho');
                else
                    changes.vcds(:,1) = misc_emissions_analysis.avg_wrf_vcds_around_loc(first_locs.locs, first_time_period, 'no2', 'radius', avg_radius);
                    changes.vcds(:,2) = misc_emissions_analysis.avg_wrf_vcds_around_loc(second_locs.locs, second_time_period, 'no2', 'radius', avg_radius);
                    changes.hcho_vcds(:,1) = misc_emissions_analysis.avg_wrf_vcds_around_loc(first_locs.locs, first_time_period, 'hcho', 'radius', avg_radius);
                    changes.hcho_vcds(:,2) = misc_emissions_analysis.avg_wrf_vcds_around_loc(second_locs.locs, second_time_period, 'hcho', 'radius', avg_radius);
                end
            end
            
            if ~ischar(avg_radius) || ~strcmpi(avg_radius, 'by_loc')
                % If we're not averaging the VCDs within the location
                % radius, we should redo the NEI emissions as well.
                
                % Add back in when can access file server again
                %changes.nei_emis(:,1) = reaverage_nei(first_locs);
                %changes.nei_emis(:,2) = reaverage_nei(second_locs);
            end
            
            changes.Location = {first_locs.locs.Location}';
            changes.ShortName = {first_locs.locs.ShortName}';
            
            function aB = a_plus_b(locs)
                a = find_substruct_field(locs, 'a');
                B = find_substruct_field(locs, 'B');
                if isempty(a) || isempty(B)
                    aB = nan;
                else
                    aB = a + B;
                end
            end
            
            function loc_emis = reaverage_nei(locs)
                first_nei_years = unique(year(locs.dvec));
                [nei_avg_no, nei_lon, nei_lat] = misc_emissions_analysis.load_nei_by_year(first_nei_years);
                loc_emis = nan(numel(locs),1);
                
                for i_eloc = 1:numel(locs)
                    % Now get the WRF grid cells within that radius of the
                    % site and add up their NEI NO emissions.
                    xx = sqrt((nei_lon - locs(i_eloc).Longitude).^2 + (nei_lat - locs(i_eloc).Latitude).^2) < avg_radius;
                    loc_emis(i_eloc) = nansum(nei_avg_no(xx));
                end
            end
            
        end
        
        function is_good = is_fit_good(x, linedens, fit_info, varargin)
            p = advInputParser;
            p.addParameter('any_num_pts', false);
            p.addParameter('DEBUG_LEVEL', 0);
            p.parse(varargin{:});
            pout = p.Results;
            
            allow_any_num_pts = pout.any_num_pts;
            DEBUG_LEVEL = pout.DEBUG_LEVEL;
            
            is_good = false;
            
            % Criteria 0: are there enough non-NaN points to give a good
            % fit? Testing with the box model shows that with only 31
            % points, the fitting procedure has a hard time fitting more
            % than a narrow range of lifetimes, but does better with 61.
            if (sum(~isnan(linedens)) < 46 || sum(~isnan(linedens)) > 70) && ~allow_any_num_pts
                if DEBUG_LEVEL > 0
                    fprintf('Fit rejected by too few line density points\n');
                end
                return
            end
            
            % Criteria 1: is R2 high enough
            if fit_info.param_stats.r2 < 0.8
                if DEBUG_LEVEL > 0
                    fprintf('Fit rejected by R2\n');
                end
                return
            end
            
            % Criteria 2: is there at least 1.5 lifetimes downwind of
            % the plume center?
            if misc_emissions_analysis.n_lifetimes_downwind(x, fit_info.ffit.x_0, fit_info.ffit.mu_x) < 1.5
                if DEBUG_LEVEL > 0
                    fprintf('Fit rejected by number of lifetimes downwind\n');
                end
                return
            end
            
            % Criteria 3: check for systematic bias in the fit
            if any(misc_emissions_analysis.test_fit_for_bias(linedens, fit_info.emgfit, 'window', 20))
                if DEBUG_LEVEL > 0
                    fprintf('Fit rejected by systematic bias test\n');
                end
                return
            end
            
            % Criteria 4: reject if sigma > x_0, because that suggests that
            % the width of the emission source might be obstructing the
            % lifetime
            if fit_info.ffit.sigma_x > fit_info.ffit.x_0
                if DEBUG_LEVEL > 0
                    fprintf('Fit rejected by width of emissions\n');
                end
                return
            end
            
            is_good = true;
        end
        
        function is_good = is_fit_good_by_loc(all_locs, varargin)
            E = JLLErrors;
            if ~isstruct(all_locs)
                E.badinput('LOC must be a structure')
            end
            
            varargin = update_params('missing', varargin, 'DEBUG_LEVEL', 1);
            
            is_good = false(size(all_locs));
            for i_loc = 1:numel(all_locs)
                loc = all_locs(i_loc);
                if ~isempty(loc.fit_info.emgfit)
                    is_good(i_loc) = misc_emissions_analysis.is_fit_good(loc.no2_sectors.x, loc.no2_sectors.linedens, loc.fit_info, varargin{:});
                end
            end
        end
        
        function n_taus = n_lifetimes_downwind(x, x_0, mu_x)
            n_taus = (max(x) - mu_x)./x_0;
        end
        
        function vcds = load_vcds_for_years(years, days_of_week, varargin)
            % LOAD_VCDS_FOR_YEARS Averages annual VCDs into multi-year periods
            %
            %   VCDS = LOAD_VCDS_FOR_YEARS( YEARS, DAYS_OF_WEEK ) Given
            %   YEARS as a numeric vector and DAYS_OF_WEEK as a string
            %   ('UMTWRFS', 'TWRF', 'US', etc.), returns the average VCDs
            %   for that time period.
            %
            %   Parameters:
            %       'species' - default 'no2', other option is 'hcho';
            %       determine which VCDs are returned.
            %
            %       'ignore_missing_files' - default false, if true, will
            %       not error if it cannot find an average VCD file for the
            %       given time period, but will error if it can't find any
            %       such file. Useful while waiting for daily BEHR files to
            %       finish being produced.
            
            E = JLLErrors;
            p = advInputParser;
            p.addParameter('species', 'no2');
            p.addParameter('season', 'summer');
            p.addParameter('ignore_missing_files', false);
            p.parse(varargin{:});
            pout = p.Results;
            
            vcd_species = pout.species;
            season = pout.season;
            ignore_missing_files = pout.ignore_missing_files;
            
            allowed_species = {'nasa_no2', 'no2','hcho'};
            if ~ismember(vcd_species, allowed_species)
                E.badinput('"vcd_species" must be one of: %s', strjoin(allowed_species, ', '))
            end
            
            if strcmpi(vcd_species, 'nasa_no2')
                struct_field = 'no2';
            else
                struct_field = vcd_species;
            end
            
            track_stddev = strcmpi(vcd_species, 'hcho');
            
            init_done = false;
            for i_yr = 1:numel(years)
                avg_filename = misc_emissions_analysis.avg_file_name(years(i_yr), days_of_week, vcd_species, 'season', season);
                try
                    year_vcds = load(avg_filename);
                catch err
                    if strcmpi(err.identifier, 'MATLAB:load:couldNotReadFile') && ignore_missing_files
                        warning('Not loading %s, file not found', avg_filename)
                        continue
                    else
                        rethrow(err);
                    end
                end
                if ~init_done
                    lon = year_vcds.daily.lon;
                    lat = year_vcds.daily.lat;
                    DailyAvg = RunningAverage();
                    MonthlyAvg = RunningAverage();
                    DailyStd = RunningAverage();
                    MonthlyStd = RunningAverage();
                    
                    adding_monthly = ~isempty(year_vcds.monthly);
                    init_done = true;
                end
                DailyAvg.addData(year_vcds.daily.(struct_field), year_vcds.daily.weights)
                if track_stddev
                    % in omhcho_time_average, the std. deviation is the
                    % column uncertainty, added in quadrature, squared at
                    % the end and divided by the sqrt of the weights, which
                    % are RMS weighted. Undo that so that we're adding
                    % the uncertainties in quadrature
                    std_daily = (year_vcds.daily.stddev .* sqrt(year_vcds.daily.weights)).^2;
                    DailyStd.addData(std_daily, year_vcds.daily.weights);
                end
                if adding_monthly
                    if ~isempty(year_vcds.monthly)
                        MonthlyAvg.addData(year_vcds.monthly.(vcd_species), year_vcds.monthly.weights)
                        if track_stddev
                            std_monthly = (year_vcds.monthly.stddev .* sqrt(year_vcds.monthly.weights)).^2;
                            MonthlyStd.addData(std_monthly, year_vcds.monthly.weights);
                        end
                    else
                        E.callError('missing_monthly_vcds', '%d average has no monthly VCDs, but previous years do', years(i_yr));
                    end
                elseif ~isempty(year_vcds.monthly)
                    warning('%d average has monthly VCDs, but prior years did not, so not including any monthly VCDs', years(i_yr));
                end
            end
            
            if ~init_done
                E.callError('no_files', 'No average files found for the specified time period');
            end
            
            vcds.lon = lon;
            vcds.lat = lat;
            vcds.daily_vcds = DailyAvg.getWeightedAverage();
            vcds.monthly_vcds = DailyAvg.getWeightedAverage();
            vcds.daily_wts = DailyAvg.weights;
            vcds.monthly_wts = MonthlyAvg.weights;
            if track_stddev
                vcds.daily_stddev = sqrt(DailyStd.getWeightedAverage()) ./ sqrt(DailyStd.weights);
                vcds.monthly_stddev = sqrt(MonthlyStd.getWeightedAverage()) ./ sqrt(MonthlyStd.weights);
            end
        end
        
        function [x, ld_array] = load_line_density_array(varargin)
            %LOAD_LINE_DENSITY_ARRAY Load all weekday line densities into one array
            %   [X, LD_ARRAY] = LOAD_LINE_DENSITY_ARRAY() Load line densities for all
            %   cities into LD_ARRAY, interpolating them to the x-coordinates, X.
            %
            %   [X, LD_ARRAY] = LOAD_LINE_DENSITY_ARRAY('days_of_week', DOW) specify
            %   the days of week to load as 'TWRF' or 'US'.
            
            p = advInputParser;
            p.addParameter('days_of_week', 'TWRF');
            p.parse(varargin{:});
            pout = p.Results;
            
            days_of_week = pout.days_of_week;
            
            x = -100:3:200;
            years = 2006:2013;
            last_city = 49;
            ld_array = nan(last_city, numel(x), numel(years));
            
            for iyr = 1:numel(years)
                yr = years(iyr);
                yr_win = (yr-1):(yr+1);
                fprintf('Loading %s\n', sprintf_ranges(yr_win));
                fits = load(misc_emissions_analysis.behr_fit_file_name(yr_win, days_of_week));
                
                for iloc = 1:last_city
                    if ~misc_emissions_analysis.is_fit_good_by_loc(fits.locs(iloc), 'any_num_pts', true, 'DEBUG_LEVEL', 0)
                        continue
                    end
                    interp_ld = interp1(fits.locs(iloc).no2_sectors.x, fits.locs(iloc).no2_sectors.linedens, x);
                    ld_array(iloc, :, iyr) = interp_ld;
                end
            end
            
        end
        
        function moves = read_moves_data(varargin)
            p = advInputParser;
            p.addParameter('domain', '');
            p.addParameter('window_width', []);
            p.addParameter('years', []);
            p.addParameter('months', []);
            p.addParameter('locations', []);
            p.addParameter('species', 3);
            p.parse(varargin{:});
            pout = p.Results;
            
            E = JLLErrors;
            
            locations = pout.locations;
            
            for i_loc = 1:numel(locations)
                if isnan(locations(i_loc).CoreCountyID)
                    E.badinput('%s does not have a core county ID specified', locations.ShortName);
                end
            end
            
            allowed_domains = {'national','core_counties'};
            if ~isempty(locations)
                % if trying to get specific locations, must use the
                % counties table.
                domain = 'core_counties';
            else
                domain = opt_ask_multichoice('Which domain', allowed_domains, pout.domain, '"domain"', 'list',true); % update to opt_ask_multichoice when there is >1 domain
            end
            
            window_width = misc_emissions_analysis.get_window_width(pout.window_width);
            species = pout.species; % todo: make accept string or number and convert string
            
            if isempty(locations)
                county_ids = [];
            else
                county_ids = [locations.CoreCountyID];
            end
            
            
            
            % Read the MOVES table now so that we know what years are
            % available
            moves_table_in = import_moves_csv(domain);
            
            xx_missing = ~ismember(county_ids, moves_table_in{:,'county_id'});
            if any(xx_missing)
                E.badinput('The county IDs for %s are not present in the MOVES table', strjoin({locations(xx_missing).ShortName}, ', '));
            end
            
            avail_years = unique(moves_table_in{:,'emis_year'});
            [min_year, max_year] = year_range_for_window(window_width);
            
            years_req = opt_ask_number(sprintf('Enter the years to include (%d-%d)',min_year,max_year), pout.years, '"years"',...
                'testfxn', @(x) all(x >= min_year & x <= max_year),...
                'testmsg', sprintf('All numbers must be between %d and %d', min_year, max_year));
            n_yr = numel(years_req);
            months_req = opt_ask_number('Enter the months to include (1-12)', pout.months, '"months"',...
                'testfxn', @(x) all(x >= 1 & x <= 12),...
                'testmsg', 'All numbers must be between 1 and 12');
            
            moves = table(years_req(:), nan(n_yr,1), 'VariableNames', {'year','emis'});
            
            for i_yr = 1:n_yr
                if window_width == 1
                    xx_yr = moves_table_in{:,'emis_year'} == years_req(i_yr);
                elseif window_width == 3
                    this_year = years_req(i_yr);
                    win_years = (this_year-1):(this_year+1);
                    xx_yr = ismember(moves_table_in{:,'emis_year'}, win_years);
                else
                    E.notimplemented('Window other that 1 or 3')
                end
                
                xx_window = xx_yr & ismember(moves_table_in{:,'emis_month'}, months_req) ...
                    & moves_table_in{:, 'species_id'} == species;
                
                nhours = (datenum(years_req(i_yr),10,1) - datenum(years_req(i_yr),4,1))*24;
                conv = 1e-3 / nhours; % convert kg/summer to Mg/h
                moves{i_yr, 2} = conv * nanmean(sum_to_year(moves_table_in(xx_window, :)));
            end
            
            
            function [min_year, max_year] = year_range_for_window(window)
                if window == 1
                    min_year = min(avail_years);
                    max_year = max(avail_years);
                elseif window == 3
                    min_year = min(avail_years) + 1;
                    max_year = max(avail_years) - 1;
                else
                    E.notimplemented('Window other that 1 or 3')
                end
            end
            
            function emis_sum = sum_to_year(moves_table)
                u_years = unique(moves_table{:,'emis_year'});
                emis_sum = nan(size(u_years));
                for i_uyr = 1:numel(u_years)
                    xx = moves_table{:,'emis_year'} == u_years(i_uyr);
                    if ~isempty(county_ids)
                        xx = xx & ismember(moves_table{:, 'county_id'}, county_ids);
                    end
                    emis_sum(i_uyr) = nansum2(moves_table{xx, 'total_emis_kg'});
                end
            end
            
            function moves_data = import_moves_csv(domain)
                %IMPORTFILE Import numeric data from a text file as a matrix.
                %   MOVESNATIONAL2005TO2014 = IMPORTFILE(FILENAME) Reads data from text
                %   file FILENAME for the default selection.
                %
                %   MOVESNATIONAL2005TO2014 = IMPORTFILE(FILENAME, STARTROW, ENDROW) Reads
                %   data from rows STARTROW through ENDROW of text file FILENAME.
                %
                % Example:
                %   movesnational2005to2014 = importfile('moves_national_2005to2014.csv', 2, 361);
                %
                %    See also TEXTSCAN.
                
                % Auto-generated by MATLAB on 2018/10/12 09:24:20
                
                % Initialize variables.
                filename = misc_emissions_analysis.moves_file(domain);
                delimiter = ',';
                startRow = 2;
                endRow = inf;
                
                % Format for each line of text:
                %   MOVES Run ID:   double (%f)
                %   MOVES Run File: strings (%s)
                %   Year:           double (%f)
                %	Month:          double (%f)
                %   Species ID Num: double (%f)
                %	Species Name:   categorical (%C)
                %   Total emis:     double (%f)
                % For more information, see the TEXTSCAN documentation.
                if strcmpi(domain,'national')
                    formatSpec = '%f%f%f%C%f%[^\n\r]';
                    varnames = {'emis_year','emis_month','species_id','species_name','total_emis_kg'};
                elseif strcmpi(domain,'core_counties')
                    formatSpec = '%f%s%f%f%f%C%f%[^\n\r]';
                    varnames = {'moves_run_id', 'moves_run_file', 'emis_year','emis_month','species_id','species_name','total_emis_kg'};
                end
                
                % Open the text file.
                fileID = fopen(filename,'r');
                
                % Read columns of data according to the format.
                % This call is based on the structure of the file used to generate this
                % code. If an error occurs for a different file, try regenerating the code
                % from the Import Tool.
                dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines', startRow(1)-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
                for block=2:length(startRow)
                    frewind(fileID);
                    dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', delimiter, 'TextType', 'string', 'HeaderLines', startRow(block)-1, 'ReturnOnError', false, 'EndOfLine', '\r\n');
                    for col=1:length(dataArray)
                        dataArray{col} = [dataArray{col};dataArrayBlock{col}];
                    end
                end
                
                % Close the text file.
                fclose(fileID);
                
                % Post processing for unimportable data.
                % No unimportable data rules were applied during the import, so no post
                % processing code is included. To generate code which works for
                % unimportable data, select unimportable cells in a file and regenerate the
                % script.
                
                % Create output variable
                moves_data = table(dataArray{1:end-1}, 'VariableNames', varnames);
                if ismember('moves_run_file', moves_data.Properties.VariableNames)
                    county_ids_strs = regexp(moves_data{:, 'moves_run_file'}, '(?<=_)\d+(?=_)', 'match', 'once');
                    moves_data{:,'county_id'} = str2double(county_ids_strs);
                    moves_data(:,'moves_run_file')=[];
                end
            end
        end
        
        function counties = read_county_shapefile()
            counties = shaperead(misc_emissions_analysis.county_shape_file);
        end
        
        function [loc_avg_vcds, loc_std_vcds, loc_n_vcds] = avg_vcds_around_loc(locs, time_period, days_of_week, varargin)
            E = JLLErrors;
            p = advInputParser;
            p.addParameter('radius', 'by_loc');
            p.addParameter('inner_rad', 0);
            p.addParameter('species', 'no2');
            p.addParameter('season', 'summer');
            p.addParameter('ignore_missing_files', false);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            avg_radius = pout.radius;
            inner_radius = pout.inner_rad;
            vcd_species = pout.species;
            season = pout.season;
            ignore_missing_files = pout.ignore_missing_files;
            
            if ischar(avg_radius)
                if strcmpi(avg_radius, 'by_loc')
                    avg_radius = [];
                else
                    E.badinput('The only valid string for "avg_radius" is "by_loc"')
                end
            end
            
            allowed_species = {'no2','nasa_no2','hcho'};
            if ~ismember(vcd_species, allowed_species)
                E.badinput('"vcd_species" must be one of: %s', strjoin(allowed_species, ', '))
            end
            
            [start_dates, end_dates] = misc_emissions_analysis.select_start_end_dates(time_period);
            time_period_years = unique(cellfun(@year, veccat(start_dates, end_dates)));
            vcds = misc_emissions_analysis.load_vcds_for_years(time_period_years, days_of_week, 'species', vcd_species, 'season', season, 'ignore_missing_files', ignore_missing_files);
            lon = vcds.lon;
            lat = vcds.lat;
            lon_res = mean(diff(lon(1,:)));
            lat_res = mean(diff(lat(:,1)));
            if abs(lon_res - lat_res) > 1e-10
                E.notimplemented('Different lon and lat resolutions');
            end
            loc_avg_vcds = nan(size(locs));
            loc_std_vcds = nan(size(locs));
            loc_n_vcds = nan(size(locs));
            loc_err_vcds = nan(size(locs));
            for i_loc = 1:numel(locs)
                % This will use the box width (from center to edge
                % perpendicular to the wind direction) as the radius and
                % find all grid points with centers within that radius.
                xx_radius = misc_emissions_analysis.find_indices_in_radius_around_loc(locs(i_loc), lon, lat, avg_radius, 'inner_rad', inner_radius);
                loc_avg_vcds(i_loc) = nanmean(vcds.daily_vcds(xx_radius));
                loc_std_vcds(i_loc) = nanstd(vcds.daily_vcds(xx_radius));
                loc_n_vcds(i_loc) = sum(xx_radius(:));
                % Disabling for now, would need to add counts to the HCHO
                % averages to do this properly. 
%                 if strcmpi(vcd_species, 'hcho')
%                     % mimics the calculation in omhcho_time_average, where
%                     % the errors are added in quadrature, and then divided
%                     % by the sqrt of the weights which are the number of
%                     % obs. We get back to the undivided err, add it in
%                     % quadrature, then redivide by the total number of obs
%                     % in the final average.
%                     err2 = (vcds.daily_stddev(xx_radius) .* sqrt(vcds.daily_wts)).^2;
%                     wts = vcds.daily_wts;
%                     loc_err_vcds(i_loc) = sqrt(nansum2(err2)) ./ sqrt(nansum2(wts));
%                 end
            end
        end
        
        function locs = average_profiles_for_locations(time_period, days_of_week, locs, varargin)
            % LOCS = AVERAGE_PROFILES_FOR_LOCATIONS( TIME_PERIOD,
            % DAYS_OF_WEEK, LOCS ) Averages default profiles from WRF for
            % each of the locations in the structure LOCS for the given
            % TIME_PERIOD and DAYS_OF_WEEK. The averaged profiles will be
            % put in a new field, WRFData, in the returned LOCS structure.
            % By default, the average of the first five levels of the
            % profiles is returned as a scalar.
            %
            % If TIME_PERIOD is a numeric vector of years, then a single
            % profile for each species is returned, averaged over all those
            % years. (If a given species is not available for one of those
            % years, it is filled by interpolation before averaging.)
            % TIME_PERIOD may also be a cell array of year vectors, in
            % which case the returned fields will be 1-by-n, where n is
            % the number of time periods requested.
            %
            % Parameters:
            %
            %   'species' - a cell array of species from WRF to average.
            %   Default is
            %   {'behr_nox','nox','omi_hcho','ho','ndens','temperature'}.
            %   'behr_nox' and 'omi_hcho' are special variables, which are
            %   the WRF NOx or HCHO profiles scaled by BEHR NO2 VCDs or OMI
            %   HCHO VCDs, respectively.
            %
            %   'levels' - indices for which levels to average to create
            %   the returned values. Default is 1:5, i.e. levels 1 to 5 of
            %   the temporally averaged profiles are included in the
            %   returned average.
            %
            %   'hcho_umtwrfs' - boolean, set to true to use OMI HCHO
            %   columns averaged over all days of week for the 'omi_hcho'
            %   specie. Default is false, will use the appropriate average
            %   for the days of the week.
            p = inputParser;
            p.addOptional('species', {'behr_nox','nox','omi_hcho','ho','ndens','temperature'});
            p.addParameter('levels', 1:5);
            p.addParameter('hcho_umtwrfs', false); % set to true to force using HCHO vcds from all days of week
            p.parse(varargin{:});
            pout = p.Results;
            
            levels = pout.levels;
            species = pout.species;
            hcho_umtwrfs = pout.hcho_umtwrfs;
            
            for i_loc = 1:numel(locs)
                locs(i_loc).WRFData = make_empty_struct_from_cell(species);
                for i_spec = 1:numel(species)
                    spec = species{i_spec};
                    if strcmpi(spec,'nox')
                        load_fxn = @(l,y) misc_wrf_lifetime_analysis.average_profiles_around_loc(l, y, 'no') + misc_wrf_lifetime_analysis.average_profiles_around_loc(l, y, 'no2');
                    elseif strcmpi(spec, 'behr_nox')
                        load_fxn = @(l,y) scale_profile(l, y, 'no2', {'no'});
                    elseif strcmpi(spec, 'omi_hcho')
                        load_fxn = @(l,y) scale_profile(l, y, 'hcho', {});
                    else
                        load_fxn = @(l,y) misc_wrf_lifetime_analysis.average_profiles_around_loc(l, y, spec);
                    end
                    
                    value = calc_with_interp(locs(i_loc), time_period, load_fxn);
                    if ~isempty(levels)
                        value = nanmean(value(levels, :), 1);
                    end
                    locs(i_loc).WRFData.(spec) = value;
                end
            end
            
            function prof = scale_profile(loc, years, vcd_specie, extra_prof_species)
                % computes a scaled profile for the given year(s). the VCDs
                % will be of the vcd_specie, the profile the sum of
                % vcd_specie and extra_prof_species (cell array). make
                % extra_prof_species an empty array if no extra species
                % needed.
                if strcmpi(vcd_specie, 'hcho') && hcho_umtwrfs
                    avg_dow = 'UMTWRFS';
                else
                    avg_dow = days_of_week;
                end
                    
                vcds = misc_emissions_analysis.avg_vcds_around_loc(loc, years, avg_dow, 'species', vcd_specie);
                pres_local = misc_wrf_lifetime_analysis.average_profiles_around_loc(loc, years, 'pres');
                vcd_prof = misc_wrf_lifetime_analysis.average_profiles_around_loc(loc, years, vcd_specie);
                total_prof = vcd_prof;
                for i_es = 1:numel(extra_prof_species)
                    total_prof = total_prof + misc_wrf_lifetime_analysis.average_profiles_around_loc(loc, years, extra_prof_species{i_es});
                end
                
                [~, scale_fac] = invert_vcd_to_mixing_ratio(vcds, vcd_prof * 1e-6, pres_local);
                prof = total_prof * scale_fac;
            end
            
            function prof = calc_with_interp(loc, years, load_prof_fxn)
                if isnumeric(years)
                    years = {years};
                end
                all_years = 2005:2014;
                prof_by_year = nan(29, numel(all_years));
                for iyr = 1:numel(all_years)
                    try
                        prof_by_year(:,iyr) = load_prof_fxn(loc, all_years(iyr));
                    catch err
                        if strcmpi(err.identifier, 'MATLAB:load:couldNotReadFile')
                            if i_loc == 1
                                fprintf('Could not load %s for %d, will interpolate\n', spec, all_years(iyr));
                            end
                        else
                            rethrow(err)
                        end
                    end
                end
                
                for z = 1:size(prof_by_year,1)
                    [~,prof_by_year(z,:)] = fill_nans(all_years, prof_by_year(z,:), 'noclip');
                end
                
                prof = nan(size(prof_by_year,1), numel(years));
                for iyr = 1:numel(years)
                    prof(:,iyr) = nanmean(prof_by_year(:, ismember(all_years, years{iyr})),2);
                end
            end
        end
        
        function VCDs = avg_wrf_vcds_around_loc(locs, time_period, specie, varargin)
            E = JLLErrors;
            p = advInputParser;
            p.addParameter('radius', 'by_loc');
            p.parse(varargin{:});
            pout = p.Results;
            
            avg_radius = pout.radius;
            
            if ~ischar(specie)
                E.badinput('SPECIE must be a char array')
            end
            
            if ischar(avg_radius)
                if strcmpi(avg_radius, 'by_loc')
                    avg_radius = [];
                else
                    E.badinput('The only valid string for "avg_radius" is "by_loc"')
                end
            end
            
            VCDs = nan(size(locs));
            [vcds, xlon, xlat] = misc_wrf_lifetime_analysis.compute_wrf_vcds_for_years(time_period, specie);
            for i_loc = 1:numel(locs)
                xx_radius = misc_emissions_analysis.find_indices_in_radius_around_loc(locs(i_loc), xlon, xlat, avg_radius);
                VCDs(i_loc) = nanmean(vcds(xx_radius));
            end
        end
        
        function [locs, xx] = cutdown_locs_by_index(locs, loc_inds, varargin)
            % Cuts down the structure LOCS to the locations specified by
            % LOCS_INDS by matching the site names from LOCS against the
            % location names in the structure read in from the spreadsheet.
            % If LOCS_INDS is an empty array, do not cut the locations down
            % at all.
            
            E = JLLErrors;
            p = advInputParser;
            p.addFlag('keep_order');
            p.parse(varargin{:});
            pout = p.Results;
            
            keep_order = pout.keep_order;
            
            if isempty(loc_inds)
                return 
            end
            
            locs_ss = misc_emissions_analysis.read_locs_file();
            ss_names = {locs_ss(loc_inds).Location};
            in_names = {locs.Location};
            if ~keep_order
                xx = ismember(in_names, ss_names);
                if sum(xx) ~= numel(loc_inds)
                    E.callError('loc_lookup_error', 'A different number of locations was found in LOCS that specified by LOC_INDS');
                end
            else
                xx = nan(size(ss_names));
                for i=1:numel(xx)
                    xx_i = find(strcmp(ss_names{i}, in_names));
                    if isempty(xx_i)
                        E.callError('loc_lookup_error', 'Could not find "%s" in the given locs structure', ss_names{i});
                    end
                    xx(i) = xx_i;
                end
            end
            locs = locs(xx);
            
        end
        
        function good_fits = create_fit_filter_vecs(filter_fit_flag, years, any_num_pts)
            if nargin < 3
                any_num_pts = true;
            end
            
            if filter_fit_flag == 0
                good_fits = true(numel(years), 71);
                return
            else
                good_fits = false(numel(years), 71);
            end
            for iyr = 1:numel(years)
                yr = years(iyr);
                yr_win = (yr-1):(yr+1);
                fprintf('Loading fits for %s\n', sprintf_ranges(yr_win))
                [sdate, edate] = misc_emissions_analysis.select_start_end_dates(yr_win);
                fit_locs = load(misc_emissions_analysis.fits_file_name(sdate, edate, false, 1:71, 'TWRF', 'lu'));
                these_good_fits = misc_emissions_analysis.is_fit_good_by_loc(fit_locs.locs, 'any_num_pts', any_num_pts, 'DEBUG_LEVEL', 0);
                good_fits(iyr, :) = these_good_fits;
            end
            
            if filter_fit_flag > 1
                good_fits = sum(good_fits, 1) >= filter_fit_flag;
                good_fits = repmat(good_fits, numel(years), 1);
            end
        end
        
        function locs = recalc_tau_uncertainty(locs, varargin)
            p = advInputParser;
            p.addParameter('percent_uncert', 10);
            p.parse(varargin{:});
            pout = p.Results;
            
            frac_uncert = pout.percent_uncert / 100;
            
            for iloc = 1:numel(locs)
                locs(iloc).emis_tau.tau_uncert = locs(iloc).emis_tau.tau * frac_uncert;
            end
        end
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Interactive utility methods %
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        function merge_linedens_files(DEBUG_LEVEL)
            E = JLLErrors;
            if ~exist('DEBUG_LEVEL', 'var')
                DEBUG_LEVEL = 2;
            end
            
            fprintf('Select the line density files to merge.\n');
            input('Press ENTER to continue','s');
            
            [files, path] = uigetfile('*.mat', 'Select files to merge', misc_emissions_analysis.line_density_dir, 'MultiSelect', 'on');
            if isequal(path,0)
                E.userCancel;
            elseif ~iscell(files)
                % files will be a character array if only one file was
                % selected; otherwise it's a cell array.
                fprintf('Must select >1 file to merge\n')
                return
            else
                % Check that all files are "sectors" or "rotated" and
                % "allwinds" or not. Also get the days of week, which
                % should be the last group of upper case characters before
                % the file extension, and some combination of U, M, T, W,
                % R, F, S.
                [is_sectors_vec, is_filtered_vec, is_weighted_vec, winds_strings, is_wrf_vec, days_of_week] = misc_emissions_analysis.extract_info_from_file_names(files);
                
                dow_check_fxn = @(d, d1) isequal(d,d1);
                
                if any(is_sectors_vec) && ~all(is_sectors_vec)
                    E.badinput('Some, but not all, of the files selected are by sectors');
                elseif any(is_filtered_vec) && ~all(is_filtered_vec)
                    E.badinput('Some, but not all, of the files selected are filtered by wind direction');
                elseif any(is_weighted_vec) && ~all(is_weighted_vec)
                    E.badinput('Some, but not all, of the files selected are weighted by wind direction counts');
                elseif any(is_wrf_vec) && ~all(is_wrf_vec)
                    E.badinput('Some, but not all, of the files selected are for BEHR data (as opposed to WRF)');
                elseif ~all(strcmp(winds_strings, winds_strings{1}))
                    E.badinput('Some, but not all, of the files selected are using all winds');
                elseif ~all(cellfun(@(x) dow_check_fxn(x, days_of_week{1}), days_of_week))
                    E.badinput('Not all of the files are for the same days of week (%s)', strjoin(days_of_week,' vs. '));
                else
                    by_sectors = all(is_sectors_vec);
                    is_filtered = all(is_filtered_vec);
                    is_weighted = all(is_weighted_vec);
                    wrf_bool = all(is_wrf_vec);
                    winds_op = regexp(winds_strings{1}, '(?<=winds\-)(lt|gt)','match','once');
                    winds_cutoff = str2double(regexp(winds_strings{1}, '(?<=winds\-[lg]t)\d','match','once'));
                    days_of_week = days_of_week{1};
                end
            end
            
            for i_file = 1:numel(files)
                if DEBUG_LEVEL > 1
                    fprintf('Loading %s\n', files{i_file});
                end
                LD(i_file) = load(fullfile(path, files{i_file}));
                
                % Check that all the date vectors are the same; we don't
                % want to merge files using different dates
                if i_file > 1 && ~isequal(LD(i_file).dvec, LD(1).dvec)
                    E.callError('datevec_mismatch', 'Different date vectors in %s and %s', files{1}, files{i_file});
                end
            end
            
            % Combine the line density structures then clear out the
            % original to save memory (can be 10+ GB).
            LD_all = make_empty_struct_from_cell(fieldnames(LD));
            % We already checked that all the date vectors are the same
            LD_all.dvec = LD(1).dvec;
            % Keep all the write dates
            LD_all.write_date = {LD.write_date};
            % Concatenate the locations, then check for and remove
            % duplicates
            LD_all.locs = veccat(LD.locs);
            clear('LD');
            
            loc_inds = misc_emissions_analysis.find_loc_struct_inds(LD_all.locs);
            
            [unique_inds, cut_down_vec] = unique(loc_inds);
            if numel(unique_inds) ~= numel(loc_inds)
                if ~ask_yn('Locations are duplicated among the files. Remove duplicates? (no will abort): ')
                    return
                end
            end
            % This will simultaneously remove duplicates and sort
            % everything.
            LD_all.locs = LD_all.locs(cut_down_vec);
            all_loc_inds = misc_emissions_analysis.find_loc_struct_inds(LD_all.locs);
            
            new_save_name = misc_emissions_analysis.line_density_file_name(LD_all.dvec(1), LD_all.dvec(end), by_sectors, is_filtered, is_weighted, wrf_bool, winds_op, winds_cutoff, all_loc_inds, days_of_week);
            if exist(new_save_name, 'file')
                if ~ask_yn(sprintf('%s exists. Overwrite? ', new_save_name))
                    return
                end
            end
            fprintf('Saving merged file as %s\n', new_save_name);
            save(new_save_name, '-v7.3', '-struct', 'LD_all');
        end
        
        function varargout = test_if_change_significant(varargin)
            p = advInputParser;
            p.addParameter('first_time_period','');
            p.addParameter('second_time_period','');
            p.addParameter('first_dow','');
            p.addParameter('second_dow','');
            
            p.parse(varargin{:});
            pout = p.Results;
            
            [~, ~, first_time_period] = misc_emissions_analysis.select_start_end_dates(pout.first_time_period);
            first_dow = misc_emissions_analysis.select_days_of_week(pout.first_dow);
            [~, ~, second_time_period] = misc_emissions_analysis.select_start_end_dates(pout.second_time_period);
            second_dow = misc_emissions_analysis.select_days_of_week(pout.second_dow);
            
            % If we select a 2-year time period, those files only have 70
            % sites
            %if strcmp(first_time_period, '2yr')
            %    file_inds = 1:70;
            %else
                file_inds = 1:71;
            %end
            if regcmp(second_time_period, '2yr') ~= regcmp(first_time_period, '2yr')
                E.notimplemented('Mix of 2 and 3 year files')
            end
            
            loc_inds = misc_emissions_analysis.get_loc_inds_interactive();
            
            [changes, loc_names] = misc_emissions_analysis.collect_changes(first_time_period, second_time_period, first_dow, second_dow, 'loc_inds', loc_inds, 'file_loc_inds', file_inds, 'include_vcds', false, 'fit_type', 'lu');
            is_significant = misc_emissions_analysis.is_change_significant(changes.tau, changes.tau_sd, changes.n_dofs);
            
            if nargout > 0
                varargout{1} = is_significant;
            else
                for i_loc = 1:numel(loc_names)
                    fprintf('%s (%s %s -> %s %s): %d\n', loc_names{i_loc}, first_time_period, first_dow, second_time_period, second_dow, is_significant(i_loc));
                end
            end
        end
        
        function loc_inds = ask_for_loc_inds(loc_inds, varargin)
            p = advInputParser;
            p.addOptional('allowed_types', {'Cities', 'PowerPlants'});
            p.parse(varargin{:});
            pout = p.Results;
            
            allowed_types = pout.allowed_types;
            
            if nargin < 1 || (isscalar(loc_inds) && isnan(loc_inds))
                ss_locs = misc_emissions_analysis.read_locs_file();
                loc_types = {ss_locs.SiteType};
                xx = ismember(loc_types, allowed_types);
                loc_names = {ss_locs(xx).Location};
                loc_inds = ask_multiselect('Select the locations to use:', loc_names, 'returnindex', true);
            end
        end
        
        %%%%%%%%%%%%%%%%%%%%%%
        % Generation methods %
        %%%%%%%%%%%%%%%%%%%%%%
        function make_summer_averages(varargin)
            function [start_date, end_date] = make_dates(avg_year)
                start_date = cell(size(avg_year));
                end_date = cell(size(avg_year));
                for a=1:numel(avg_year)
                    start_date{a} = datenum(avg_year(a), 4, 1);
                    end_date{a} = datenum(avg_year(a), 9, 30);
                end
            end
            
            misc_emissions_analysis.make_vcd_averages(@make_dates, 'summer', varargin{:});
        end
        
        function make_winter_averages(varargin)
            function [start_date, end_date] = make_dates(avg_year)
                start_date = cell(2, numel(avg_year));
                end_date = cell(2, numel(avg_year));
                for a=1:numel(avg_year)
                    start_date{1,a} = datenum(avg_year(a), 1, 1);
                    end_date{1,a} = datenum(avg_year(a), 3, 31);
                    start_date{2,a} = datenum(avg_year(a), 10, 1);
                    end_date{2,a} = datenum(avg_year(a), 12, 31);
                end
                start_date = start_date(:);
                end_date = end_date(:);
            end
            
            misc_emissions_analysis.make_vcd_averages(@make_dates, 'winter', varargin{:});
        end
        
        function make_vcd_averages(date_fxn, season, varargin)
            % MAKE_SUMMER_AVERAGES Make summertime averages of NO2 or HCHO
            % VCDs.
            %
            % Parameter:
            %   'avg_year' - which year to average.
            %   'days_of_week' - see class help
            %   'species' - 'NO2' or 'HCHO'.
            E = JLLErrors;
            p = inputParser;
            p.addParameter('avg_year',[]);
            p.addParameter('days_of_week','');
            p.addParameter('species','');
            p.parse(varargin{:});
            pout = p.Results;
            
            avg_year = pout.avg_year;
            days_of_week = pout.days_of_week;
            species = pout.species;
            
            if isempty(avg_year)
                avg_year = ask_number('Enter the year (or years separated by a space) to do a summer average for', 'testfxn', @(x) all(x >= 2005 & x <= 2015), 'testmsg', 'Year(s) must be between 2005 and 2015');
            elseif ~isnumeric(avg_year) || any(avg_year < 2005 | avg_year > 2015)
                E.badinput('AVG_YEAR must be a numeric vector with values between 2005 and 2015');
            end
            
            days_of_week = misc_emissions_analysis.choose_days_of_week(days_of_week);
            species = opt_ask_multichoice('Which species to average?', {'NO2', 'HCHO', 'NASA_NO2'}, species, '"species"');
            
            [start_date, end_date] = date_fxn(avg_year);
            
            % Make the monthly profile product average, then try to make
            % the daily one. If there's no data, it will return a NaN
            common_opts = {'DEBUG_LEVEL', 1, 'dayofweek', days_of_week};
            if strcmpi(species, 'nasa_no2')
                common_opts = veccat(common_opts, {'avgfield', 'ColumnAmountNO2Trop'});
            end
            switch lower(species)
                case {'no2','nasa_no2'}
                    %[monthly.no2, monthly.lon, monthly.lat, monthly.weights] = behr_time_average(start_date, end_date, 'prof_mode', 'monthly', common_opts{:});
                    monthly = [];
                    [daily.no2, daily.lon, daily.lat, daily.weights] = behr_time_average(start_date, end_date, 'prof_mode', 'daily', common_opts{:});
                case 'hcho'
                    [monthly.hcho, monthly.lon, monthly.lat, monthly.weights, monthly.stddev] = omhcho_time_average(start_date, end_date, common_opts{:});
                    daily = monthly;
            end
            
            save_name = misc_emissions_analysis.avg_file_name(avg_year, days_of_week, species, 'season', season);
            save(save_name, 'monthly', 'daily');
        end
        
        function make_location_winds_file(time_period, overwrite)
            % MAKE_LOCATIONS_WINDS_FILE(TIME_PERIOD, OVERWRITE) Make
            % average wind speed and direction files from WRF data.
            % As in Laughner, Zare, and Cohen (2016, ACP) we will calculate
            % wind direction by averaging over the first 5 WRF layers in a
            % 3x3 grid centered on each location.
            
            misc_emissions_analysis.verify_git_state();
            
            if ~exist('time_period', 'var')
                time_period = '';
            end
            
            if ~exist('overwrite', 'var')
                overwrite = -1;
            end
            
            locs = misc_emissions_analysis.read_locs_file();
            [start_date, end_date] = misc_emissions_analysis.select_start_end_dates(time_period);
            dvec = misc_emissions_analysis.make_datevec(start_date, end_date);
            
            % Check that the save file exists
            save_file = misc_emissions_analysis.winds_file_name(start_date, end_date);
            if exist(save_file, 'file')
                % If overwrite isn't specified, ask. Otherwise, if it is
                % false and the file exists, abort.
                if overwrite < 0 && ~ask_yn(sprintf('%s already exists. Overwrite?', save_file))
                    return
                elseif ~overwrite
                    return
                end
            end
            
            wind_array = nan(numel(dvec), 6); % ndates x norbits per date (usually 4, sometimes 5, so 6 should be plenty)
            wind_cell = cell(size(wind_array));
            for a=1:numel(locs)
                locs(a).WindDir = wind_array;
                locs(a).WindSpeed = wind_array;
                locs(a).U = wind_cell;
                locs(a).V = wind_cell;
            end
            
            last_month = -1;
            last_year = -1;
            for d=1:numel(dvec)
                % We need to pick the WRF file closest in time to the OMI
                % overpass, so we will load the BEHR file for this day and
                % calculate which WRF file is closest in time to that
                % swath, then calculate wind speed and direction for each
                % file. Later, we will actually pick the swath-specific
                % wind direction for each rotation.
                
                % If we're in the same month as the last time through this
                % loop, the closest_wrf method doesn't need to get the
                % directory listing of the WRF directory again (because it
                % should be organized by month and year).
                fprintf('%s: Gathering WRF files\n', datestr(dvec(d)));
                try
                    if month(dvec(d)) == last_month && year(dvec(d)) == last_year
                        fprintf('     Using existing list of WRF files\n');
                        wrf_files = misc_emissions_analysis.closest_wrf_file_in_time(dvec(d), all_months_wrf_files);
                    else
                        fprintf('     New month: need to get the directory listing\n');
                        [wrf_files, all_months_wrf_files] = misc_emissions_analysis.closest_wrf_file_in_time(dvec(d));
                        last_month = month(dvec(d));
                        last_year = year(dvec(d));
                    end
                catch err
                    if strcmp(err.identifier, 'MATLAB:load:couldNotReadFile')
                        fprintf('Cannot load file for %s, skipping\n', datestr(dvec(d)));
                        continue
                    else
                        rethrow(err)
                    end
                end
                
                % Load the bottom five layers of U and V, plus COSALPHA and
                % SINALPHA
                for a=1:numel(wrf_files)
                    fprintf('  %s, swath %d: Reading wind and lat/lon\n', datestr(dvec(d)), a);
                    U = ncread(wrf_files{a}, 'U', [1 1 1 1], [Inf, Inf, 5, Inf]);
                    V = ncread(wrf_files{a}, 'V', [1 1 1 1], [Inf, Inf, 5, Inf]);
                    cosalpha = ncread(wrf_files{a}, 'COSALPHA');
                    sinalpha = ncread(wrf_files{a}, 'SINALPHA');
                    wrf_lon = ncread(wrf_files{a}, 'XLONG');
                    wrf_lat = ncread(wrf_files{a}, 'XLAT');
                    
                    U = unstagger(U,1);
                    V = unstagger(V,2);
                    [U, V] = wrf_winds_transform(U,V,cosalpha,sinalpha);
                    
                    % As in Laughner et al. 2016, we average over the
                    % vertical layers first (c.f. misc_behr_wind_plots.m,
                    % subfunction plot_wind_magnitude_and_angle in
                    % https://github.com/behr-github/BEHR-WindEffect-analysis)
                    % Theoretically, this should be the same as averaging
                    % over all 45 values at once (I think)
                    U = nanmean(U,3);
                    V = nanmean(V,3);
                    
                    % Now loop over each location and calculate its wind
                    % for that swath
                    fprintf('  %s, swath %d: Averaging to locations\n', datestr(dvec(d)), a);
                    for l=1:numel(locs)
                        [xx,yy] = misc_emissions_analysis.find_indicies_in_box_around_point(locs(l), wrf_lon, wrf_lat, 1);
                        Ubar = nanmean(reshape(U(xx,yy),[],1));
                        Vbar = nanmean(reshape(V(xx,yy),[],1)); 
                        
                        locs(l).WindSpeed(d,a) = sqrt(Ubar.^2 + Vbar.^2);
                        locs(l).WindDir(d,a) = atan2d(Vbar,Ubar);
                        
                        % We'll also store the vertically averaged wind
                        % fields for checking later
                        locs(l).U{d,a} = U(xx,yy);
                        locs(l).V{d,a} = V(xx,yy);
                    end
                end
            end
            
            locs = misc_emissions_analysis.mark_which_winds_will_be_used(locs, dvec); %#ok<NASGU>
            
            write_date = datestr(now); %#ok<NASGU>
            
            save(save_file, 'locs', 'dvec', 'write_date');
        end
        
        function locs = mark_which_winds_will_be_used(locs, dvec)
            % Iterate through the dates used for each location and estimate
            % which winds will actually be used based on rotated_plume.
            % This is used in order to weight the slow wind speed data to
            % have the same fractional contribution to a given wind
            % direction, for which we don't just want to count up all
            % instances of wind falling in a directional bin, just those
            % that have actual satellite data.
            
            % Copied from calc_line_density on 26 Mar 2018.
            reject_details = struct('cloud_type', 'omi', 'cloud_frac', 0.2, 'row_anom_mode', 'XTrackFlags', 'check_behr_amf', true);
            
            % Initialize the WindUsedBool field for all locations
            for i_loc = 1:numel(locs)
                locs(i_loc).WindUsedBool = false(size(locs(i_loc).WindDir));
            end
            
            % Iterate over dates in the outer loop since we need to load
            % the BEHR file for each day.
            for i_date = 1:numel(dvec)
                if all(isnan(locs(1).WindSpeed(i_date,:)))
                    fprintf('No wind speeds defined for %s, so leaving all false\n', datestr(dvec(i_date)));
                    continue
                end
                fprintf('Marking useful winds for %s\n', datestr(dvec(i_date)));
                Data = load_behr_file(dvec(i_date),'daily','us');
                for i_orbit = 1:numel(Data)
                    Data(i_orbit).Areaweight = ones(size(Data(i_orbit).Longitude));
                    Data(i_orbit) = omi_pixel_reject(Data(i_orbit),'detailed',reject_details);
                    for i_loc = 1:numel(locs)
                        if strcmp(locs(i_loc).SiteType, 'RuralAreas')
                            % Rural areas do not have boxes defined, so we
                            % can't use rotate_plume here, but they aren't
                            % used in this analysis anyway.
                            continue
                        end
                        
                        xx_pixels_used = rotate_plume(Data(i_orbit), locs(i_loc).Longitude, locs(i_loc).Latitude, locs(i_loc).WindDir(i_date, i_orbit), locs(i_loc).BoxSize, 'pixels_in_box', true);
                        locs(i_loc).WindUsedBool(i_date, i_orbit) = any(Data(i_orbit).Areaweight(xx_pixels_used) > 0);
                    end
                end
            end
        end
        
        function make_location_wrf_avgs_file(time_periods, overwrite)
            % Make an average file of WRF quantities. This function should
            % be deprecated in favor of
            % misc_wrf_lifetime_analysis.make_wrf_averages.
            E = JLLErrors;
            wrf_2d_vars = {'ndens', 'temperature', 'ho', 'LNOXHNO3', 'LNOXA'};
            wrf_3d_vars = {'no', 'no2', 'ho', 'pres'};
            wrf_vars = veccat(wrf_2d_vars, wrf_3d_vars);

            if ~exist('overwrite', 'var')
                overwrite = -1;
            end
            
            base_locs = misc_emissions_analysis.read_locs_file();
            base_locs_names = {base_locs.ShortName};
            
            n_files_per_day = 6; % should match the assumed number for the winds files
            n_2d_vars = numel(wrf_2d_vars);
            n_3d_vars = numel(wrf_3d_vars);
            n_vars = numel(wrf_vars);
            n_wrf_levels = 29;
            n_locs = numel(base_locs);
            n_times = numel(time_periods);
            
            winds_data = cell(n_times,1);
            for i_time = 1:n_times
                [start_date, end_date] = misc_emissions_analysis.select_start_end_dates(time_periods{i_time});
                winds_data{i_time} = load(misc_emissions_analysis.winds_file_name(start_date, end_date));
                
                % Double check that the winds structs match the base locs
                tmp_locs = winds_data{i_time}.locs;
                loc_names = {tmp_locs.ShortName};
                if ~isequal(loc_names, base_locs_names)
                    E.notimplemented('Winds locs different from base locs')
                end
                
                % Append a substructure to put the WRF data into. Have one
                % value per day, we'll average together whichever hours are
                % used.
                field_2d = 'Averaged';
                field_3d = 'Profile';
                for i_loc=1:n_locs
                    data_struct_2d = make_empty_struct_from_cell(wrf_2d_vars, nan(1, size(tmp_locs(i_loc).WindUsedBool,1)));
                    data_struct_3d = make_empty_struct_from_cell(wrf_3d_vars, nan(n_wrf_levels, size(tmp_locs(i_loc).WindUsedBool,1)));
                    tmp_locs(i_loc).WRFData.(field_2d) = data_struct_2d;
                    tmp_locs(i_loc).WRFData.(field_3d) = data_struct_3d;
                end
                winds_data{i_time}.locs = tmp_locs;
                
                winds_data{i_time}.savename = misc_emissions_analysis.wrf_data_file_name(start_date, end_date);
            end
            
            all_years = unique(veccat(time_periods{:}));
            [total_starts, total_ends] = misc_emissions_analysis.select_start_end_dates(all_years);
            total_dvec = make_datevec(total_starts, total_ends);
            
            WRF_Files_Getter = BEHRMatchedWRFFiles('DEBUG_LEVEL', 1);
            
            for d=1:numel(total_dvec)
                this_date = total_dvec(d);
                fprintf('Now on %s (%d of %d)\n', datestr(this_date), d, numel(total_dvec));
                % We need to pick the WRF file closest in time to the OMI
                % overpass, so we will load the BEHR file for this day and
                % calculate which WRF file is closest in time to that
                % swath, then calculate wind speed and direction for each
                % file. Later, we will actually pick the swath-specific
                % wind direction for each rotation.
                
                % If we're in the same month as the last time through this
                % loop, the closest_wrf method doesn't need to get the
                % directory listing of the WRF directory again (because it
                % should be organized by month and year).
                fprintf('%s: Gathering WRF files\n', datestr(total_dvec(d)));
                wrf_files = WRF_Files_Getter.get_files_for_date(total_dvec(d));
                if isempty(wrf_files)
                    continue
                end
                
                data_for_today = nan(n_wrf_levels, n_files_per_day, n_vars, n_locs);
                
                for i_file=1:numel(wrf_files)
                    % Load the bottom five layers of each variable in turn,
                    % average it to the cities radii, then for each time
                    % period, figure out if this date is in it, if so, get
                    % the data for the right time for that city, and store
                    % it.
                    wrf_lon = ncread(wrf_files{i_file}, 'XLONG');
                    wrf_lat = ncread(wrf_files{i_file}, 'XLAT');
                    for i_var = 1:n_vars
                        is_2d = is_var_2d(i_var);
                        var_name = wrf_vars{i_var};
                        fprintf('    Loading %s\n', wrf_vars{i_var});

                        if is_2d
                            num_lev = 5;
                        else
                            num_lev = Inf;
                        end

                        try
                            wrf_value = read_wrf_preproc(wrf_files{i_file}, var_name, [1 1 1 1], [Inf Inf num_lev Inf]);
                        catch err
                            if any(strcmpi(err.identifier, {'MATLAB:imagesci:netcdf:unableToOpenFileforRead','MATLAB:imagesci:netcdf:unknownLocation'}))
                                fprintf('Cannot read %s from %s, it will stay a NaN\n', wrf_vars{i_var}, wrf_files{i_file});
                                continue
                            else
                                rethrow(err)
                            end
                        end

                        if is_2d
                            wrf_value = nanmean(wrf_value, 3);
                        else
                            wrf_value = permute(wrf_value, [3 1 2]);
                            if size(wrf_value,1) ~= n_wrf_levels
                                E.callError('wrf_level_mismatch', 'WRF levels for variable "%s" not the expected %d', var_name, n_wrf_levels);
                            end
                        end
                        
                        for i_loc = 1:n_locs
                            xx = misc_emissions_analysis.find_indices_in_radius_around_loc(base_locs(i_loc), wrf_lon, wrf_lat);
                            if is_2d
                                data_for_today(1, i_file, i_var, i_loc) = nanmean(wrf_value(xx));
                            else
                                data_for_today(:, i_file, i_var, i_loc) = nanmean(wrf_value(:,xx),2);
                            end
                        end
                    end
                    
                end
                
                fprintf('Average to locations...\n');
                for i_time = 1:n_times
                    xx_date = winds_data{i_time}.dvec == this_date;
                    if sum(xx_date) < 1
                        fprintf('  %s not in time period %d\n', datestr(this_date), i_time);
                        continue
                    elseif sum(xx_date) > 1
                        E.notimplemented('Date matched multiple dates in location file')
                    end
                    
                    for i_loc=1:n_locs
                        xx_hours = winds_data{i_time}.locs(i_loc).WindUsedBool(xx_date, :);
                        for i_var=1:n_vars
                            is_2d = is_var_2d(i_var);
                            if is_2d
                                loc_var_value = nanmean(data_for_today(1, xx_hours, i_var, i_loc));
                                substruct = field_2d;
                            else
                                loc_var_value = nanmean(data_for_today(:, xx_hours, i_var, i_loc),2);
                                substruct = field_3d;
                            end
                            winds_data{i_time}.locs(i_loc).WRFData.(substruct).(wrf_vars{i_var})(:, xx_date) = loc_var_value;
                        end
                    end
                end
            end
            
            for i_time=1:n_times
                savename = winds_data{i_time}.savename;
                savedata = rmfield(winds_data{i_time}, 'savename');
                save(savename, '-v7.3', '-struct', 'savedata' );
            end

            function yn = is_var_2d(ind)
                yn = ind <= n_2d_vars;
            end
        end
        
        function make_rotated_line_densities(varargin)
            % MAKE_ROTATED_LINE_DENSITIES() will make the line densities
            % aligning all wind directions for all locations, asking before
            % overwriting existing files.
            %
            % MAKE_ROTATED_LINE_DENSITIES( LOC_INDICIES ) will restrict the
            % locations to those given at locs(LOC_INDICIES) in the winds
            % file (misc_emissions_analysis.winds_file_name). It will do
            % this before removing rural sites. Will still ask to overwrite
            % existing file.
            %
            % MAKE_ROTATED_LINE_DENSITIES( LOC_INDICIES, OVERWRITE ) given
            % OVERWRITE == 0, will not overwrite an existing file and
            % OVERWRITE > 0 will overwrite an existing file. OVERWRITE < 0
            % will ask before overwriting.
            %
            % This is for making the normal EMG-fitting line densities used
            % in Laughner and Cohen 2019.
            if ~any(strcmp('winds_op', varargin)) && ~any(strcmp('winds_cutoff', varargin))
                varargin(end+1:end+4) = {'winds_op', 'gt', 'winds_cutoff', 3};
            end
            misc_emissions_analysis.make_line_densities(false, varargin{:});
        end
        
        function make_rotated_slow_convolution_line_densities(varargin)
            % MAKE_ROTATED_SLOW_CONVOLUTION_LINE_DENSITIES() will call
            % make_line_densities() with the following parameters enforced:
            %
            %       'weight_wind_dirs' = true
            %       'use_wind_rejects' = false
            %       'winds_op' = 'lt'
            %       'winds_cutoff' = misc_emissions_analysis.fast_slow_sep
            %
            % This is for making the slow wind line densities for the
            % convolution method in Liu 2016
            % (www.atmos-chem-phys.net/16/5283/2016/0.
            varargin = update_params(varargin, 'weight_wind_dirs', true, 'use_wind_rejects', false, 'winds_op', 'lt', 'winds_cutoff', misc_emissions_analysis.fast_slow_sep);
            misc_emissions_analysis.make_line_densities(false, varargin{:});
        end
        
        function make_rotated_fast_convolution_line_densities(varargin)
            % MAKE_ROTATED_FAST_CONVOLUTION_LINE_DENSITIES() will call
            % make_line_densities() with the following parameters enforced:
            %
            %       'weight_wind_dirs' = false
            %       'use_wind_rejects' = false
            %       'winds_op' = 'gt'
            %       'winds_cutoff' = misc_emissions_analysis.fast_slow_sep
            %
            % This is for generating line densities under fast winds for a
            % method similar to that in Liu 2016
            % (www.atmos-chem-phys.net/16/5283/2016/).
            varargin = update_params(varargin, 'weight_wind_dirs', false, 'use_wind_rejects', false, 'winds_op', 'gt', 'winds_cutoff', misc_emissions_analysis.fast_slow_sep);
            misc_emissions_analysis.make_line_densities(false, varargin{:});
        end
        
        function make_sector_line_densities(varargin)
            % MAKE_SECTOR_LINE_DENSITIES() will make the line densities for
            % separate wind direction sectors for all locations, asking
            % before overwriting existing files.
            %
            % MAKE_SECTOR_LINE_DENSITIES( LOC_INDICIES ) will restrict the
            % locations to those given at locs(LOC_INDICIES) in the winds
            % file (misc_emissions_analysis.winds_file_name). It will do
            % this before removing rural sites. Will still ask to overwrite
            % existing file.
            %
            % MAKE_SECTOR_LINE_DENSITIES( LOC_INDICIES, OVERWRITE ) given
            % OVERWRITE == 0, will not overwrite an existing file and
            % OVERWRITE > 0 will overwrite an existing file. OVERWRITE < 0
            % will ask before overwriting.
            if ~any(strcmp('winds_op', varargin)) && ~any(strcmp('winds_cutoff', varargin))
                varargin(end+1:end+4) = {'winds_op', 'lt', 'winds_cutoff', 3};
            end
            misc_emissions_analysis.make_line_densities(true, varargin{:});
        end
        
        function make_line_densities(by_sectors, varargin)
            % MAKE_LINE_DENSITIES Create line density output files.
            %
            %   MAKE_LINE_DENSITIES( BY_SECTORS )
            %
            %   Not really intended to be called directly, there are other
            %   make_*_line_densities functions that will pass some of the
            %   necessary arguments automatically to make sure this is set
            %   up correctly. One required argument, BY_SECTORS, which must
            %   be a scalar logical value, indicating if line densities
            %   should be divided up into sectors (true), or rotated
            %   (false).
            %
            %   Parameters:
            %
            %   'time_period' - which time period to calculate line
            %   densities for. Must be a string recognized by
            %   select_start_end_dates(). If empty, will prompt for the
            %   time period (default).
            %
            %   'loc_indicies' - a numeric vector indicated which locations
            %   to calculate line densities for by their index in the
            %   locations spreadsheet. If empty (default) all are 
            %   calculated.
            %
            %   'do_overwrite' - scalar logical that indicates whether
            %   existing line density file should be overwritten. If -1
            %   (default), will prompt.
            %
            %   'days_of_week' - which days of week to include in the line
            %   density. Must be a string containing some subset of the
            %   characters UMTWRFS. Default is all days of week.
            %
            %   'winds_op' - the string 'gt' (default) or 'lt', which in
            %   conjunction with 'winds_cutoff' (next) determines the
            %   criteria for wind speed. 'gt' = greater than, 'lt' = less
            %   than
            %
            %   'winds_cutoff' - a scalar number indicating the wind speed
            %   criteria that goes with 'winds_op'.
            %
            %   'use_nasa' - a scalar logical indicating whether to use
            %   BEHR column densities (false) or NASA column densities
            %   (true).
            %
            %   'use_wrf' - a scalar logical indicating whether to use VCDs
            %   derived from WRF model simulation (using the
            %   preproc_AprioriVCDs utility in this repository). By
            %   default, this will use the WRFWindRejects field of the
            %   locations spreadsheet to determine which wind directions to
            %   ignore; that can be overridden by 'use_wrf_wind_rejects'.
            %   This will also not filter the line densities for cloud or
            %   row anomaly.
            %
            %   'use_wind_rejects' - a boolean that determines whether wind
            %   directions listed in the locations spreadsheet should be
            %   skipped. Default is true, false will use all wind
            %   directions.
            %
            %   'use_wrf_wind_rejects' - if rejecting by wind direction,
            %   this controls whether it uses the WindRejects (false) or
            %   WRFWindRejects (true) field in the spreadsheet. By default
            %   this is set to match 'use_wrf', but you may override that.
            %
            %   'weight_wind_dirs' - boolean, default false, that indicates
            %   whether the contribution of each wind sector to the line
            %   density should be weighted. Each sector is weighted by the
            %   number of days in it that have fast winds divided by those
            %   with slow winds; it is intended to be used to weight slow
            %   wind conditions for use with the convolution algorithm.
            %
            %   'grid_method' - see ROTATE_PLUME.
            
            E = JLLErrors;
            
            if ~islogical(by_sectors) || ~isscalar(by_sectors)
                E.badinput('BY_SECTORS must be a scalar logical')
            end
            
            p = advInputParser;
            p.addParameter('time_period', '');
            p.addParameter('loc_indices', []);
            p.addParameter('do_overwrite', -1);
            p.addParameter('days_of_week', 'UMTWRFS');
            p.addParameter('winds_op', 'gt')
            p.addParameter('winds_cutoff', 3);
            p.addParameter('use_nasa', false);
            p.addParameter('use_wrf', false);
            p.addParameter('wrf_var', '');
            p.addParameter('use_wind_rejects',true);
            p.addParameter('use_wrf_wind_rejects', nan);
            p.addParameter('weight_wind_dirs',false);
            p.addParameter('grid_method', 'cvm');
            
            p.parse(varargin{:});
            pout = p.AdvResults;
            
            misc_emissions_analysis.verify_git_state();
            
            time_period = pout.time_period;
            loc_indicies = pout.loc_indices;
            do_overwrite = pout.do_overwrite;
            days_of_week = pout.days_of_week;
            winds_op = pout.winds_op;
            winds_cutoff = pout.winds_cutoff;
            use_nasa = pout.use_nasa;
            wrf_bool = pout.use_wrf;
            wrf_var = pout.wrf_var;
            use_wind_rejects = pout.use_wind_rejects;
            use_wrf_rejects = pout.use_wrf_wind_rejects;
            weight_wind_dirs = pout.weight_wind_dirs;
            grid_method = pout.grid_method;
            
            if ~isnumeric(loc_indicies) || any(loc_indicies(:) < 1)
                E.badinput('The parameter "loc_indicies" must be a numeric array with all values >= 1')
            end
            
            if (~isnumeric(do_overwrite) && ~islogical(do_overwrite)) || ~isscalar(do_overwrite)
                E.badinput('The parameter "do_overwrite" must be a scalar logical or number')
            end
            
            if isnan(use_wrf_rejects)
                use_wrf_rejects = wrf_bool;
            end
            
            [start_date, end_date] = misc_emissions_analysis.select_start_end_dates(time_period);
 
            % Find the list of BEHR files between the start and end dates
            if ~wrf_bool
                [behr_files, behr_dir] = list_behr_files(start_date, end_date,'daily','all');
            else
                behr_dir = misc_emissions_analysis.wrf_vcd_dir;
                %behr_dir = '/home/josh/Documents/MATLAB/BEHR-emissions-analysis/Workspaces/debugging';
                behr_files = dir(fullfile(behr_dir,'WRF*.mat'));
                file_dates = date_from_behr_filenames(behr_files);
                dvec_tmp = make_datevec(start_date, end_date);
                behr_files(~ismember(file_dates, dvec_tmp)) = [];
            end
            % If we're doing line densities by sector, then we don't want
            % to reject any wind directions. We also don't want to reject
            % wind directions if explicitly told not to.
            filter_by_wind_dir = use_wind_rejects && ~by_sectors;
            if ~filter_by_wind_dir
                wind_reject_field = 'none';
            elseif use_wrf_rejects
                wind_reject_field = 'WRFWindRejects';
            else
                wind_reject_field = 'WindRejects';
            end
            
            % If overwrite not given and the save file exists, ask to
            % overwrite. Otherwise, only overwrite if instructed.
            type_indicator = misc_emissions_analysis.nasa_wrf_int(wrf_bool, use_nasa);
            save_name = misc_emissions_analysis.line_density_file_name(start_date, end_date, by_sectors, filter_by_wind_dir, weight_wind_dirs, type_indicator, winds_op, winds_cutoff, loc_indicies, days_of_week, wrf_var);
            if exist(save_name, 'file')
                if do_overwrite < 0
                    if ~ask_yn(sprintf('%s exists. Overwrite?', save_name))
                        return
                    end
                elseif ~do_overwrite
                    return
                end
            end
           
            fprintf('Will save as %s\n', save_name);
            
            % Load the winds file with up-to-date box sizes and wind
            % sectors to reject
            winds = misc_emissions_analysis.load_winds_file(start_date, end_date);
            winds.locs = misc_emissions_analysis.append_new_spreadsheet_fields(winds.locs);
            
            
            
            % Check that the dates match up with what we're expecting (it
            % should because we load the file with those dates). Also check
            % that it matches up with the BEHR filenames.
            check_dvec = misc_emissions_analysis.make_datevec(start_date, end_date);
            if ~isequal(check_dvec, winds.dvec)
                E.callError('date_mismatch', 'Dates in winds file do not match required (%s to %s, %d dates)', datestr(start_date(1)), datestr(end_date(end)), numel(check_dvec));
            end
            
            behr_dvec = date_from_behr_filenames(behr_files);
            if ~isequal(winds.dvec(:), behr_dvec(:))
                warning('date_mismatch:behr_winds', 'Dates in winds file do not match the BEHR_files, cutting down');
                dd = ~ismember(winds.dvec, behr_dvec);
                winds.dvec(dd) = [];
                if ~isequal(winds.dvec(:), behr_dvec(:))
                    E.notimplemented('Winds file dates and behr dates are in different orders')
                end
                for i_loc = 1:numel(winds.locs)
                    winds.locs(i_loc).WindDir(dd,:) = [];
                    winds.locs(i_loc).WindSpeed(dd,:) = [];
                    winds.locs(i_loc).U(dd,:) = [];
                    winds.locs(i_loc).V(dd,:) = [];
                    winds.locs(i_loc).WindUsedBool(dd,:) = [];
                end
            end

            if ~isempty(loc_indicies)
                winds.locs = misc_emissions_analysis.cutdown_locs_by_index(winds.locs, loc_indicies);
            end
            % Rural sites aren't going to be that interesting
            xx = strcmpi('Cities', {winds.locs.SiteType}) | strcmpi('PowerPlants', {winds.locs.SiteType});
            winds.locs(~xx) = [];
            % This should allow the substructure "locs" to be a sliced,
            % instead of broadcast, variable
            winds_locs_distributed = winds.locs;
            
            % Set up a default box size in case the spreadsheet has an
            % invalid box size.
            default_box = [1 2 1 1];
            
            % Should we weight the line densities by the ratio of the
            % number of times the winds go in a given direction when they
            % are slow vs. fast? If so, append the necessary arguments to
            % the call to calc_line_density. (Right now will not affect
            % sectors.)
            
            if weight_wind_dirs
                [wind_dir_weights, wind_dir_edges] = misc_emissions_analysis.calculate_wind_bin_weights(winds.locs, winds_cutoff, 'all_winds', false);
            else
                % When we hit the parfor loop, Matlab will try to transmit 
                % all variables needed in the loop to the workers. It does 
                % not care that wind_dir_weights and wind_dir_edges aren't
                % needed if weight_wind_dirs is false, so we have to give 
                % these some fill value to avoid a "variable not defined"
                % error. These are actually sliced variables in the parfor 
                % loop, so they need to be the same size as winds.locs 
                % because the parfor loop will try to send e.g. wind_dir_weights{20}
                % to the worker doing a=20.
                wind_dir_weights = cell(size(winds.locs));
                wind_dir_edges = cell(size(winds.locs));
            end
            
            parfor a=1:numel(winds.locs)
                opt_args = {'sectors', by_sectors};
                
                box_size = winds_locs_distributed(a).BoxSize;
                if any(isnan(box_size))
                    warning('NaN detected in box size. Setting to default %s for location %s', mat2str(default_box), winds_locs_distributed(a).ShortName)
                    box_size = default_box;
                end
                
                if weight_wind_dirs && ~by_sectors
                    opt_args = veccat(opt_args, {'wind_dir_weights', wind_dir_weights{a}, 'wind_weights_bins', wind_dir_edges{a}});
                end
                
                if wrf_bool
                    opt_args = veccat(opt_args, {'no_reject', true});
                    if ~isempty(wrf_var)
                        opt_args = veccat(opt_args, {'linedens_field', wrf_var});
                    end
                elseif use_nasa
                    opt_args = veccat(opt_args, {'linedens_field', 'nasa'});
                end
                
                % "wind_reject_field" will have been set to 'none' if
                % either doing sectors or told explicitly not to filter by
                % wind direction. This will always filter by wind speed
                % though.
                wind_logical = misc_emissions_analysis.set_wind_conditions(winds_locs_distributed(a), winds_cutoff, winds_op, wind_reject_field);

                fprintf('Calculating line densities for %s\n', winds_locs_distributed(a).ShortName);
                [no2(a).x, no2(a).linedens, no2(a).linedens_std, no2(a).lon, no2(a).lat, no2(a).no2_mean, no2(a).no2_std, no2(a).num_valid_obs, no2(a).nox, no2(a).debug_cell] ...
                    = calc_line_density(behr_dir, behr_files, winds_locs_distributed(a).Longitude, winds_locs_distributed(a).Latitude, winds_locs_distributed(a).WindDir, wind_logical,...
                    'rel_box_corners', box_size, 'days_of_week', days_of_week, opt_args{:});
            end
            
            for a=1:numel(winds.locs)
                winds.locs(a).no2_sectors = no2(a);
            end
            
            locs = winds.locs;
            dvec = winds.dvec;
            write_date = datestr(now);
            if wrf_bool
                ld_variable = wrf_var;
            elseif use_nasa
                ld_variable = 'ColumnAmountNO2Trop';
            else
                ld_variable = 'BEHRColumnAmountNO2Trop';
            end
            
            save(save_name, '-v7.3', 'locs', 'dvec', 'write_date', 'ld_variable');
        end
        
        function locs = make_emg_fits(varargin)
            % MAKE_EMG_FITS Generate the EMG fits of the line densities.
            % Also calculates the NOx lifetime and emission rate and their
            % uncertainties.
            %
            % Parameters:
            %   'time_period' - see class help
            %   
            %   'loc_indicies' - see class help
            %
            %   'file_loc_indicies' - see class help
            %
            %   'add_nei' - boolean, set to true to include NEI emissions
            %   calculated by averaging NEI NO emissions from WRF-Chem
            %   within the standard radius of each location.
            %
            %   'days_of_week' - see class help
            %
            %   'wrf_var' - set to a non-empty char array to use WRF data
            %   instead, specifically, give the name of the variable to
            %   fit.
            %
            %   'do_overwrite' - set to true to overwrite existing fit
            %   files, false to not. By default, will ask each time.
            %
            %   'max_fit_attempts' - this function fits each line density
            %   twice and, if the two attempts yield different fits, tries
            %   again. This parameter limits the number of times it tries.
            %   Default is 2.
            %
            %   'fatal_fit_fail' - if true (default), then any failure to
            %   fit a line density results in an error. If false, then any
            %   failed fit is given an empty structure in the file and the
            %   function continues to the next location.
            %
            %   'skip_linedens_errors' - if there is an actual error during
            %   fitting (as opposed to the fit failing to converge), this
            %   controls what happens. By default, it asks interactively
            %   what to do. Setting to true will just skip that location,
            %   false will throw an error.
            %
            %   'fit_type' - either 'lu' or 'convolution', using the
            %   standard EMG fit with rotated line densities ('lu') or the
            %   slow-line density-convolution method of Liu 2016
            %   (www.atmos-chem-phys.net/16/5283/2016/). The latter was not
            %   successful, but the code to do it is retained.
            %
            %   'ld_scale' - a factor to multiply line densities by during
            %   fitting. The scaled line densities replace the original
            %   ones in the EMG fit files. This is necessary because the
            %   fitting expects the line densities in a particular range of
            %   values, and some WRF variables exceed that.
            E = JLLErrors;
            p = inputParser;
            p.addParameter('time_period', '');
            p.addParameter('loc_indicies', []);
            p.addParameter('file_loc_indicies','match'); % if set to 'match' then this will be the same as loc_indicies.
            p.addParameter('add_nei', true);
            p.addParameter('days_of_week', 'UMTWRFS');
            p.addParameter('wrf_var', '');
            p.addParameter('use_nasa', false);
            p.addParameter('do_overwrite', -1);
            % by default if it doesn't get it the second time, then it's
            % probably just going to randomly sample until it happens to
            % get two runs that give the same fit, which there's no reason
            % to believe that is the minimum.
            p.addParameter('max_fit_attempts', 2);  
            p.addParameter('fatal_fit_fail', true);
            p.addParameter('skip_linedens_errors', -1);
            p.addParameter('fit_type', '');
            p.addParameter('ld_scale', 1);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            time_period = pout.time_period;
            loc_indicies = pout.loc_indicies;
            file_loc_indicies = pout.file_loc_indicies;
            add_nei = pout.add_nei;
            days_of_week = pout.days_of_week;
            wrf_var = pout.wrf_var;
            use_nasa = pout.use_nasa;
            do_overwrite = pout.do_overwrite;
            max_fit_attempts = pout.max_fit_attempts;
            fatal_if_cannot_fit = pout.fatal_fit_fail;
            skip_linedens_errors = pout.skip_linedens_errors;
            fit_type_in = pout.fit_type;
            ld_scale = pout.ld_scale;
            % time_period should be checked in select_start_end_dates
            
            if ~isnumeric(loc_indicies) || any(loc_indicies(:) < 1)
                E.badinput('LOC_INDICIES must be a numeric array with all values >= 1')
            end
            
            if strcmpi(file_loc_indicies, 'match')
                file_loc_indicies = loc_indicies;
            elseif ~isnumeric(file_loc_indicies) || any(file_loc_indicies(:) < 1)
                E.badinput('FILE_LOC_INDICIES must be a numeric array with all values >= 1 or the string "match"')
            end
            
            if ~isscalar(add_nei) || (~islogical(add_nei) && ~isnumeric(add_nei))
                E.badinput('ADD_NEI must be a scalar logical or numeric value');
            end
            
            if ~ischar(days_of_week)
                E.badinput('DAYS_OF_WEEK must be a character array');
            end
            
            if (~isnumeric(do_overwrite) && ~islogical(do_overwrite)) || ~isscalar(do_overwrite)
                E.badinput('DO_OVERWRITE must be a scalar logical or number')
            end
            
            fit_type_in = misc_emissions_analysis.get_fit_type_interactive(fit_type_in);
            wrf_bool = ~isempty(wrf_var);
            type_indicator = misc_emissions_analysis.nasa_wrf_int(wrf_bool, use_nasa);
            
            [start_date, end_date] = misc_emissions_analysis.select_start_end_dates(time_period);
            % If overwrite not given and the save file exists, ask to
            % overwrite. Otherwise, only overwrite if instructed.
            save_name = misc_emissions_analysis.fits_file_name(start_date, end_date, type_indicator, loc_indicies, days_of_week, fit_type_in, wrf_var);
            if exist(save_name, 'file')
                if do_overwrite < 0
                    if ~ask_yn(sprintf('%s exists. Overwrite?', save_name))
                        return
                    end
                elseif ~do_overwrite
                    [~,save_basename] = fileparts(save_name);
                    fprintf('%s exists already. Not overwriting\n', save_basename);
                    return
                end
            end
            
            
            if strcmpi(fit_type_in, 'convolution')
                % For the convolution approach, we want the fast line
                % densities to be unfiltered for wind direction (because in
                % theory the convolution with the slow line densities will
                % handle the downwind sources we had to filter out in the
                % normal way) and unweighted (fast line densities should
                % always be unweighted for wind diretion contribution).
                filtered_bool = false;
                weighted_bool = false;
                % However for the slow line densities we do want them
                % weighted for wind direction contribution so that they
                % match the fast line densities.
                slow_ldens_file = misc_emissions_analysis.line_density_file_name(start_date, end_date, false, filtered_bool, true, type_indicator, 'lt', misc_emissions_analysis.fast_slow_sep, file_loc_indicies, days_of_week, wrf_var);
                if ~exist(slow_ldens_file, 'file')
                    [~,ldens_basename] = fileparts(slow_ldens_file);
                    % Use regular error function to have more control over the
                    % error identifier
                    error('emis_analysis:no_linedens_file', 'Slow line density file %s not found, cannot fit EMG functions', ldens_basename);
                end
                slow_line_densities = load(slow_ldens_file);
            else
                % Load the file with the line densities. For this, we never
                % want the sectors line densities (first false) and usually
                % want the file with winds greater than the separation
                % speed (3 m/s as of 27 Mar 2018).
                filtered_bool = true;
                weighted_bool = false;
                slow_line_densities = [];
            end
            ldens_file = misc_emissions_analysis.line_density_file_name(start_date, end_date, false, filtered_bool, weighted_bool, type_indicator, 'gt', misc_emissions_analysis.fast_slow_sep, file_loc_indicies, days_of_week, wrf_var);
            if ~exist(ldens_file, 'file')
                [~,ldens_basename] = fileparts(ldens_file);
                % Use regular error function to have more control over the
                % error identifier
                error('emis_analysis:no_linedens_file', 'Line density file %s not found, cannot fit EMG functions', ldens_basename);
            end
            line_densities = load(ldens_file);
            
            if ~isempty(loc_indicies)
                locs = misc_emissions_analysis.cutdown_locs_by_index(line_densities.locs, loc_indicies);
                if ~isempty(slow_line_densities)
                    slow_line_densities.locs = misc_emissions_analysis.cutdown_locs_by_index(slow_line_densities.locs, loc_indicies);
                end
            else
                locs = line_densities.locs;
            end
            
            % Load the NEI data. Will need to get lat/lon from
            % wrfinput_d01, b/c the wrfchemi files don't include lat-lon.
            % Would have to do some work to get this to run on the cluster.
            if add_nei
                nei_year = unique(year(line_densities.dvec));
                [nei_avg_no, nei_lon, nei_lat] = misc_emissions_analysis.load_nei_by_year(nei_year);
            end
            % Specify even the default options so that if fit_line_density
            % changes, we know exactly what options we wanted.
            common_opts = {'fmincon_output', 'none', 'fittype', 'ssresid', 'nattempts', 20};
            if strcmpi(fit_type_in, 'convolution')
                % In Liu 2016, when she applies the convolved line
                % densities, the center offset in the exponential is set to
                % 0. I assume this is because the slow line densities
                % should already contain information about the true center
                % point of the emission.
                common_opts = veccat(common_opts, {'fixed_param','mux','fixed_val',0});
                
                % We also need to indicate that the mu_x and sigma_x
                % parameters don't matter when checking if the two fitting
                % attempts are the same
                fit_check_inds = [1 2 5];
            else
                fit_check_inds = 1:5;
            end
            
            for a=1:numel(locs)
                fprintf('Fitting %s\n', locs(a).ShortName);
                % Scale the stored line densities deliberately - this avoids
                % issues later where the line densities don't match up with
                % the EMG fit (e.g. in the systematic bias criteria for
                % fit goodness)
                locs(a).no2_sectors.linedens = locs(a).no2_sectors.linedens * ld_scale;
                if strcmpi(fit_type_in, 'convolution')
                    slow_line_densities.locs(a).no2_sectors.linedens = slow_line_densities.locs(a).no2_sectors.linedens*ld_scale;
                end
                safety_count = 1;
                while true
                    if strcmpi(fit_type_in, 'convolution')
                        fit_type = convolved_fit_function(slow_line_densities.locs(a).no2_sectors.x, slow_line_densities.locs(a).no2_sectors.linedens);
                    else
                        fit_type = fit_type_in;
                    end
                    try
                        [ffit, emgfit, param_stats, f0, history, fitresults] = fit_line_density(locs(a).no2_sectors.x, locs(a).no2_sectors.linedens, 'emgtype', fit_type, common_opts{:});
                        % Try this a second time - if it gives a different
                        % answer, we should re-run, since that suggests we
                        % didn't find the minimum one time.
                        ffit_check = fit_line_density(locs(a).no2_sectors.x, locs(a).no2_sectors.linedens, 'emgtype', fit_type, common_opts{:});
                    catch err
                        msg = sprintf('Fitting %s failed with error:\n "%s"\nSkip this location and continue?', locs(a).ShortName, err.message);
                        if skip_linedens_errors > 0 || (skip_linedens_errors < 0 && ask_yn(msg))
                            locs(a).fit_info = misc_emissions_analysis.default_fit_structure;
                            break
                        else
                            rethrow(err)
                        end
                    end
                        
                    
                    % Check that the two are the same to within 1%
                    diff_tolerance = 0.01;
                    rdel = reldiff(struct2array(ffit_check), struct2array(ffit));
                    if all(abs(rdel(fit_check_inds)) < diff_tolerance)
                        locs(a).fit_info = struct('ffit',ffit,'emgfit',emgfit,'param_stats',param_stats,'f0',f0,'history',history,'fitresults',fitresults);
                        break
                    elseif safety_count > max_fit_attempts
                        msg = sprintf('Could not fit %s in %d attempts', locs(a).ShortName, max_fit_attempts);
                        if fatal_if_cannot_fit
                            E.callError('fit_failure', msg);
                        else
                            fprintf('%s\n', msg);
                            locs(a).fit_info = misc_emissions_analysis.default_fit_structure;
                            break
                        end
                    else
                        fprintf('Attempt %d of %d: fit results differ by > %f%% (%s vs %s); retrying\n', safety_count, max_fit_attempts, diff_tolerance*100, struct2string(ffit), struct2string(ffit_check));
                        safety_count = safety_count + 1;
                    end
                end
                
                if ~isequal(locs(a).fit_info, misc_emissions_analysis.default_fit_structure)
                    % Add the emissions and lifetime. Use the 95% confidence
                    % intervals as the uncertainty. We need to restrict the
                    % winds to what should have been used to calculate the line
                    % densities.
                    [ ~, ~, ~, winds_strings ] = misc_emissions_analysis.extract_info_from_file_names(ldens_file);
                    % Assuming that "winds_strings" is of the form
                    % winds-lt# or winds-gt#, then
                    % winds_strings(end-2:end-1) will give the wind mode
                    % (less than or greater than) and converting
                    % winds_strings(3) to a number will give the speed.
                    wind_logical = misc_emissions_analysis.set_wind_conditions(locs(a), str2double(winds_strings(end)), winds_strings(end-2:end-1));
                    % We can use the WindUsedBool field if available to
                    % further constrain the winds to those from times when
                    % there were valid NO2 observations
                    if isfield(locs(a),'WindUsedBool')
                        wind_logical = wind_logical & locs(a).WindUsedBool;
                    else
                        warning('No "WindUsedBool" field detected; all winds that meet the speed criterion will be used in the lifetime/emissions calcuation');
                    end
                    emis_tau = misc_emissions_analysis.calculate_emission_lifetime(locs(a).no2_sectors, locs(a).fit_info, locs(a).WindSpeed(wind_logical));
                    
                    if add_nei
                        % Calculate the across-wind distance from the rotated
                        % latitude grid - since we rotate to the "x" (i.e.
                        % east-west) axis, across wind == latitudinally
                        across_wind_radius = abs((locs(a).no2_sectors.lat(1,1) - locs(a).no2_sectors.lat(end,1))/2);
                        
                        % Now get the WRF grid cells within that radius of the
                        % site and add up their NEI NO emissions.
                        xx = sqrt((nei_lon - locs(a).Longitude).^2 + (nei_lat - locs(a).Latitude).^2) < across_wind_radius;
                        
                        emis_tau.nei_emis = nansum(nei_avg_no(xx));
                    end
                    
                    locs(a).emis_tau = emis_tau;
                else
                    locs(a).emis_tau = misc_emissions_analysis.default_emis_tau_structure;
                end
            end
            
            dvec = line_densities.dvec;
            write_date = datestr(now);
            
            save(save_name, '-v7.3', 'locs', 'dvec', 'write_date');
        end
        
        function make_average_wrf_profiles(varargin)
            
            warning('This function is deprecated in favor of make_wrf_averages')
            
            p = advInputParser;
            p.addParameter('time_period','');
            p.addParameter('relevant_hours', 15:23);
            p.addParameter('num_workers', nan);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            time_period = pout.time_period;
            hours_to_load = pout.relevant_hours;
            num_workers = pout.num_workers;
            active_pool = gcp('nocreate');
            if isnan(num_workers)
                if isempty(active_pool)
                    num_workers = 0;
                else
                    num_workers = active_pool.NumWorkers;
                end
            elseif isempty(active_pool)
                active_pool = parpool(num_workers);
            end
            
            if iscell(time_period)
                start_dates = time_period(1,:);
                end_dates = time_period(2,:);
            else
                [start_dates, end_dates] = misc_emissions_analysis.select_start_end_dates(time_period);
            end
            
            dvec = make_datevec(start_dates, end_dates);
            % This needs to be separate because we need a non-distributed
            % version for use outside the spmd block.
            distributed_dvec = distributed(dvec);
            profile_running_avgs = Composite(num_workers);
            vars_to_load = {'no','no2','hcho','pres'};
            n_vars = numel(vars_to_load);
            spmd(num_workers)
                local_dvec = getLocalPart(distributed_dvec);
                fprintf('Worker %d will do %s to %s\n', labindex, datestr(local_dvec(1)), datestr(local_dvec(end)));
                local_avgs = cell(1, n_vars);
                for i_var = 1:n_vars
                    local_avgs{i_var} = RunningAverage();
                end
                
                for i_date = 1:numel(local_dvec)
                    fprintf('  Loading files from %s\n', datestr(local_dvec(i_date)));
                    wrf_date = local_dvec(i_date);
                    wrf_dir = find_wrf_path('us','daily',wrf_date);
                    wrf_files = dir(fullfile(wrf_dir, sprintf('wrfout_*_%s*',datestr(wrf_date, 'yyyy-mm-dd'))));
                    wrf_hours = hour(date_from_wrf_filenames(wrf_files));
                    xx = ismember(wrf_hours, hours_to_load);
                    wrf_files(~xx) = [];
                    data = read_wrf_vars(wrf_dir, wrf_files, vars_to_load, 'squeeze', 0, 'as_struct');
                    if i_date == 1
                        xlon = ncread(fullfile(wrf_dir, wrf_files(1).name), 'XLONG');
                    end
                    
                    for i_var = 1:n_vars
                        tmp_var = wrf_day_weighted_average(xlon, 13.5, hours_to_load, data.(vars_to_load{i_var}));
                        local_avgs{i_var}.addData(tmp_var{1});
                    end
                end
                
                % Setting the value of a composite variable inside and SPMD
                % loop sets the value for this worker in the overall
                % composite.
                %
                % We want to pass the running averages back out because we
                % need to add up the running averages across all of the
                % workers.
                profile_running_avgs = local_avgs;
            end
            
            data = make_empty_struct_from_cell(vars_to_load);
            for i_var = 1:n_vars
                var_avg = RunningAverage();
                for i_worker = 1:numel(profile_running_avgs)
                    sub_avg = profile_running_avgs{i_worker};
                    % since adding data to a running average multiplies it
                    % by the weight, and getting the weighted average
                    % divides by the weight, to "append" weighted averages
                    % like this, we need to add the average, weighted by
                    % its weights, or we end up double-counting the weights
                    var_avg.addData(sub_avg{i_var}.getWeightedAverage(), sub_avg{i_var}.weights);
                end
                data.(vars_to_load{i_var}) = var_avg.getWeightedAverage();
            end
            
            % Add longitude and latitude
            wrf_file = find_wrf_path('us','daily',dvec(1),'fullpath');
            data.lon = ncread(wrf_file, 'XLONG');
            data.lat = ncread(wrf_file, 'XLAT');
            
            save(misc_emissions_analysis.wrf_avg_prof_file(start_dates, end_dates), '-struct', 'data', '-v7.3');
        end
        
        function [x,y] = center_and_normalize(varargin)
            % CENTER_AND_NORMALIZE - Alias to same function in
            % misc_pecans_lifetime_plots. See docs there.
            [x,y] = misc_pecans_lifetime_plots.center_and_normalize(varargin{:});
        end
        %%%%%%%%%%%%%%%%%%%%
        % Plotting methods %
        %%%%%%%%%%%%%%%%%%%%
        
        function plot_site_summer_avg(varargin)
            % Plot the summer average NO2 VCDs around locations
            
            warning('This function is pretty old and may not be compatible with the final data')
            E = JLLErrors;
            
            p = inputParser;
            p.addParameter('loc_to_plot', '');
            p.addParameter('plot_year',[]);
            p.addParameter('days_of_week', '');
            p.addParameter('monthly_or_daily', '');
            p.addParameter('plot_axis', gobjects(0));
            
            p.parse(varargin{:});
            pout = p.Results;
            
            loc_to_plot = pout.loc_to_plot;
            plot_year = pout.plot_year;
            days_of_week = pout.days_of_week;
            monthly_or_daily = pout.monthly_or_daily;
            plot_axis = pout.plot_axis;
            
            locs = misc_emissions_analysis.read_locs_file();
            loc_names = {locs.ShortName};
            if isempty(loc_to_plot)
                loc_to_plot = ask_multichoice('Which location to plot?', loc_names, 'list', true);
            elseif ~any(strcmpi(loc_to_plot, loc_names))
                E.badinput('LOC_TO_PLOT must be one of the shortname in the trend locations file');
            end
            
            i_loc = strcmpi(loc_names, loc_to_plot);
            
            if isempty(plot_year)
                plot_year = ask_number('Enter the year (or years separated by a space) to do a summer average for', 'testfxn', @(x) all(x >= 2005 & x <= 2015), 'testmsg', 'Year(s) must be between 2005 and 2015');
            elseif ~isnumeric(plot_year)
                E.badinput('PLOT_YEAR must be numeric')
            end
            
            days_of_week = misc_emissions_analysis.choose_days_of_week(days_of_week);
            file_to_plot = misc_emissions_analysis.avg_file_name(plot_year, days_of_week);
            if ~exist(file_to_plot, 'file')
                E.badinput('No average file for year %d and days of week %s', plot_year, days_of_week);
            end   
            
            allowed_mod_strings = {'both', 'monthly', 'daily'};
            if isempty(monthly_or_daily)
                monthly_or_daily = 'both';
            elseif ~ismember(monthly_or_daily, allowed_mod_strings)
                E.badinput('MONTHLY_OR_DAILY must be one of: %s', allowed_mod_strings);
            end
            
            % From the average file, find the point near the given
            % location, then go out to 3x the radius given in the locs file
            avgs = load(file_to_plot);
            
            % Radius is in km, the lon and lats are in degrees. Assume ~110
            % km/deg.
            grid_del = abs(diff(avgs.monthly.lon(1,1:2)));
            radius_deg = locs(i_loc).Radius / 110;
            n_cells = ceil(radius_deg * 3 / grid_del);
            [yy, xx] = misc_emissions_analysis.find_indicies_in_box_around_point(locs(i_loc), avgs.monthly.lon, avgs.monthly.lat, n_cells);
            
            loc_longrid = avgs.monthly.lon(yy,xx);
            loc_latgrid = avgs.monthly.lat(yy,xx);
            if ismember(monthly_or_daily, {'both', 'monthly'})
                loc_no2grid = avgs.monthly.no2(yy,xx);
                figure;
                pcolor(loc_longrid, loc_latgrid, loc_no2grid);
                line(locs(i_loc).Longitude, locs(i_loc).Latitude, 'marker', 'p', 'color', 'k', 'linestyle', 'none');
                cb=colorbar;
                cb.Label.String = 'NO_2 VCD (molec. cm^{-2})';
                set(gca,'fontsize',16);
                shading flat;
                caxis(calc_plot_limits(loc_no2grid(:), 1e15, 'zero', 'max', [0 Inf]));
                title(sprintf('%s - Monthly profiles (%s, %s)', locs(i_loc).ShortName, sprintf_ranges(plot_year, 'value_sep', ', '), days_of_week));
            end
            % If daily profile avgs are available too, plot them as well
            if ~isscalar(avgs.daily.no2) && ismember(monthly_or_daily, {'both', 'daily'}) % if no data, the no2 grid will just be a scalar NaN
                loc_no2grid = avgs.daily.no2(yy,xx);
                if isempty(plot_axis)
                    figure; 
                    pcolor(loc_longrid, loc_latgrid, loc_no2grid);
                else
                    pcolor(plot_axis, loc_longrid, loc_latgrid, loc_no2grid);
                end
                line(locs(i_loc).Longitude, locs(i_loc).Latitude, 'marker', 'p', 'color', 'k', 'linestyle', 'none');
                cb=colorbar;
                cb.Label.String = 'NO_2 VCD (molec. cm^{-2})';
                set(gca,'fontsize',16);
                shading flat;
                caxis(calc_plot_limits(loc_no2grid(:), 1e15, 'zero', 'max', [0 Inf]));
                title(sprintf('%s - Daily profiles (%s %s)', locs(i_loc).ShortName, sprintf_ranges(plot_year, 'value_sep', ', '), days_of_week));
            end
        end
        
        function plot_both_sectors_interactive()
            % This will load the sites NO2 sectors file once then
            % continuously loop and let the user pick which location to
            % plot. It will then plot both the line densities and the
            % column densities by sector to help me decide which directions
            % to keep.
            avail_ld_files = dir(fullfile(misc_emissions_analysis.line_density_dir, '*.mat'));
                
            if numel(avail_ld_files) == 1
                ld_file = avail_ld_files(1).name;
            else
                ld_file = ask_multichoice('Select the sector line density file to use', {avail_ld_files.name}, 'list', true);
            end
            
            ld_file = fullfile(misc_emissions_analysis.line_density_dir, ld_file);
            locs_data = load(ld_file);
            locs_available = locs_data.locs;
            locs_dvec = locs_data.dvec;
            
            while true
                loc_inds = ask_multiselect('Choose the site(s) to plot', {locs_available.ShortName}, 'returnindex', true);
                locs_to_plot = locs_available(loc_inds);
                
                figs(1) = misc_emissions_analysis.plot_site_sectors_linedens(locs_to_plot, locs_dvec);
                figs(2) = misc_emissions_analysis.plot_sector_no2avg_with_boxes(locs_to_plot);
                
                tilefigs;
                
                if ~ask_yn('Plot another location?')
                    break
                else
                    close(figs)
                end
            end
        end
        
        function sectors_fig = plot_site_sectors_linedens(locs_to_plot, locs_dvec)
            % Plot line densities for each of the 8 wind direction sectors.
            E = JLLErrors;
            if nargin < 2
                avail_ld_files = dir(fullfile(misc_emissions_analysis.line_density_dir, '*.mat'));
                
                if numel(avail_ld_files) == 1
                    ld_file = avail_ld_files(1).name;
                else
                    ld_file = ask_multichoice('Select the sector line density file to use', {avail_ld_files.name}, 'list', true);
                end
                
                ld_file = fullfile(misc_emissions_analysis.line_density_dir, ld_file);
                locs_data = load(ld_file);
                locs_to_plot = locs_data.locs;
                locs_dvec = locs_data.dvec;
                
                loc_inds = ask_multiselect('Choose the site(s) to plot', {locs_to_plot.ShortName}, 'returnindex', true);
                locs_to_plot = locs_to_plot(loc_inds);
                
            elseif ~isstruct(locs_to_plot) || ~isfield(locs_to_plot, 'no2_sectors')
                E.badinput('LOCS_TO_PLOT must be a structure with field "no2_sectors"');
            end
            
            % Also load the summer average column density file so that we
            % can plot that as the center figure.
            locs_year = unique(year(locs_dvec));
            
            % Map the subplot index to the proper direction
            direction_names = {'NW','N','NE','W','vcds','E','SW','S','SE'};
            for a=1:numel(locs_to_plot)
                sectors_fig = figure;
                for b=1:9
                    ax=subplot(3,3,b);
                    if strcmpi(direction_names{b}, 'vcds')
                        misc_emissions_analysis.plot_site_summer_avg(locs_to_plot(a).ShortName, locs_year, 'daily', ax);
                        cb=colorbar;
                        cb.Label.String = 'NO_2 VCD (molec. cm^{-2})';
                        line(locs_to_plot(a).Longitude, locs_to_plot(a).Latitude, 'linestyle','none','marker','p','linewidth',2,'color','k');
                    else
                        plot(locs_to_plot(a).no2_sectors.x.(direction_names{b}), locs_to_plot(a).no2_sectors.linedens.(direction_names{b}));
                        xlabel('Dist. to site (km)');
                        ylabel('Line density (mol km^{-1})');
                        title(direction_names{b});
                    end
                end
            end
        end
        
        function sectors_fig = plot_sector_no2avg_with_boxes(locs_to_plot)
            % Plot NO2 VCDs for each of the 8 wind direction sectors with
            % the line density box overlaid.
            %
            % This function is used for determining if certain wind
            % directions should be omitted.
            if ~exist('locs_to_plot', 'var')
                avail_ld_files = dir(fullfile(misc_emissions_analysis.line_density_dir, '*.mat'));
                
                if numel(avail_ld_files) == 1
                    ld_file = avail_ld_files(1).name;
                else
                    ld_file = ask_multichoice('Select the sector line density file to use', {avail_ld_files.name}, 'list', true);
                end
                
                ld_file = fullfile(misc_emissions_analysis.line_density_dir, ld_file);
                locs_data = load(ld_file);
                locs_to_plot = locs_data.locs;
                
                loc_inds = ask_multiselect('Choose the site(s) to plot', {locs_to_plot.ShortName}, 'returnindex', true);
                locs_to_plot = locs_to_plot(loc_inds);
                
            elseif ~isstruct(locs_to_plot) || ~isfield(locs_to_plot, 'no2_sectors')
                E.badinput('LOCS_TO_PLOT must be a structure with field "no2_sectors"');
            end
            
            % Loop through the directions, plotting the average NO2 VCDs
            % with four different size boxes.
            direction_names = {'NW','N','NE','W','','E','SW','S','SE'};
            direction_angles = [135, 90, 45, 180, NaN, 0, -135, -90, -45];
            for a=1:numel(locs_to_plot)
                sectors_fig = figure;
                boxes_rel_x = [-0.5 1 1 -0.5 -0.5;...
                               -1 2 2 -1 -1;...
                               -2 4 4 -2 -2];
                boxes_rel_y = [-0.5 -0.5 0.5 0.5 -0.5;...
                               -1 -1 1 1 -1;...
                               -2 -2 2 2 -2];
                for b=1:9
                    subplot(3,3,b);
                    if isempty(direction_names{b})
                        title(locs_to_plot(a).Location);
                        axis off
                        continue
                    end
                    [lon, lat] = misc_emissions_analysis.rotate_lon_lat(locs_to_plot(a).no2_sectors.lon, locs_to_plot(a).no2_sectors.lat, locs_to_plot(a).Longitude, locs_to_plot(a).Latitude, direction_angles(b));
                    box_lon = boxes_rel_x + locs_to_plot(a).Longitude;
                    box_lat = boxes_rel_y + locs_to_plot(a).Latitude;
                    [box_lon, box_lat] = misc_emissions_analysis.rotate_lon_lat(box_lon, box_lat, locs_to_plot(a).Longitude, locs_to_plot(a).Latitude, direction_angles(b));
                    
                    pcolor(lon, lat, locs_to_plot(a).no2_sectors.no2_mean.(direction_names{b}));
                    shading flat; colorbar
                    for c=1:size(box_lon,1)
                        line(box_lon(c,:), box_lat(c,:), 'linewidth', 2, 'linestyle', '--', 'color', 'k');
                    end
                    title(direction_names{b});
                end
            end
        end
        
        function plot_sat_nei_emissions()
            % Plot a bar graph of OMI derived and NEI derived emissions.
            
            loc_inds = misc_emissions_analysis.get_loc_inds_interactive();
            
            if numel(loc_inds) > 1
                allowed_time_periods = {'beginning','end','both'};
                plot_time_period = ask_multichoice('Which time period(s) to plot?', allowed_time_periods, 'list', true);
                plot_beginning = any(strcmpi(plot_time_period, {'beginning','both'}));
                plot_end = any(strcmpi(plot_time_period, {'end','both'}));
                time_inds = [plot_beginning, plot_end];
            else
                time_inds = true(1,2);
            end
            
            
            
            [changes, loc_names] = misc_emissions_analysis.collect_changes('beginning','end','UMTWRFS','UMTWRFS','loc_inds',loc_inds);
            if numel(loc_inds) == 1
                % If only plotting one location, then we can split up the
                % bars more nicely than if plotting multiple locations
                plot_data = cat(2, changes.emis', changes.nei_emis');
                legend_str = {'Top-down (BEHR)','Bottom-up (NEI)'};
                legend_inds = true(size(legend_str));
                xticklabels =  {'2005,07','2012-13'};
                axis_opts = {'xticklabels', xticklabels(time_inds), 'fontsize',14};
            else
                plot_data = cat(2, changes.emis(:,time_inds), changes.nei_emis(:,time_inds));
                legend_inds = [time_inds(1), time_inds(2), time_inds(1), time_inds(2)]; % needed for the legend string
                legend_str = {'05-07 Top-down (BEHR)','12-13 Top-down (BEHR)','05-07 Bottom-up (NEI)','12-13 Bottom-up (NEI)'};
                axis_opts = {'xticklabels', loc_names', 'xticklabelrotation', 30, 'fontsize', 14};
            end
            
            figure;
            bar(plot_data);
            set(gca, axis_opts{:});
            legend(legend_str{legend_inds});
            ylabel('NO Emissions (Mg h^{-1})');
            
        end
        
        function plot_fits_interactive(varargin)
            % Plot line densities and fits for different locations
            % interactively. 
            %
            % Currently out of date.
            
            error('This function is out of date and needs updated to work with the numeric 3 year time periods')
            p = inputParser;
            p.addParameter('loc_indicies', [])
            p.addParameter('include_2yr', nan);
            
            p.parse(varargin{:});
            pout = p.Results;
            loc_inds = pout.loc_indicies;
            include_2yr = opt_ask_yn('Include 2yr periods?', pout.include_2yr, '"include_2yr"');
            
            % Load the weekday, weekend, and all day fits files. Cut out
            % the memory intensive parts of the line density sub structure
            % to save memory.
            [use_wrf, loc_inds_wrf] = misc_emissions_analysis.ask_to_use_wrf();
            if isempty(loc_inds)
                loc_inds = loc_inds_wrf;
            end
            
            [periods.beg.start_date, periods.beg.end_date] = misc_emissions_analysis.select_start_end_dates('beginning');
            periods.beg.loc_inds = loc_inds;
            [periods.end.start_date, periods.end.end_date] = misc_emissions_analysis.select_start_end_dates('end');
            periods.end.loc_inds = loc_inds;
            if include_2yr
                [periods.beg2yr.start_date, periods.beg2yr.end_date] = misc_emissions_analysis.select_start_end_dates('beg_2yr');
                periods.beg2yr.loc_inds = 1:70;  % The 2-year files only have 70 locations
                [periods.end2yr.start_date, periods.end2yr.end_date] = misc_emissions_analysis.select_start_end_dates('end_2yr');
                periods.end2yr.loc_inds = 1:70;
            end
            
            fit_type = misc_emissions_analysis.get_fit_type_interactive();
            
            
            
            periods_fns = fieldnames(periods);
            for i_period = 1:numel(periods_fns)
                per_fn = periods_fns{i_period};
                days_of_week = {'UMTWRFS', 'TWRF', 'US'};
                loc_prototype = struct('Location', '', 'x', [], 'linedens', [], 'emgfit', [], 'r2', []);
                periods.(per_fn).locs = repmat(loc_prototype, numel(loc_inds), numel(days_of_week));
                
                for i_dow = 1:numel(days_of_week)
                    the_fits = load(misc_emissions_analysis.fits_file_name(periods.(per_fn).start_date, periods.(per_fn).end_date, use_wrf, periods.(per_fn).loc_inds, days_of_week{i_dow}, fit_type));
                    for i_loc = 1:numel(the_fits.locs)
                        periods.(per_fn).locs(i_loc, i_dow) = copy_structure_fields(the_fits.locs(i_loc), loc_prototype, 'substructs');
                    end
                end
            end
            % Now we can actually do the plotting. Make a list of the
            % available locations, then ask which one to plot until we quit
            locs_list = {periods.(periods_fns{1}).locs(:,1).Location};
            colors = {[0.5 0.5 0.5], 'c', [1 0.5 0];...
                      'k'          , 'b', 'r'};
            while true
                loc_ind = ask_multichoice('Plot which location?', locs_list, 'list', true, 'index', true);
                figs = gobjects(size(periods_fns));
                for i_period = 1:numel(periods_fns)
                    figs(i_period) = figure;
                    this_period = periods.(periods_fns{i_period});
                    l = gobjects(size(this_period.locs,2),1);
                    for i_wkday = 1:size(this_period.locs,2)
                        l(i_wkday) = line(this_period.locs(loc_ind, i_wkday).x, this_period.locs(loc_ind, i_wkday).linedens, 'color', colors{1, i_wkday}, 'marker', 'o', 'linestyle', 'none');
                        if ~isempty(this_period.locs(loc_ind, i_wkday).emgfit)
                            line(this_period.locs(loc_ind, i_wkday).x, this_period.locs(loc_ind, i_wkday).emgfit, 'color', colors{2, i_wkday}, 'linestyle', '--');
                        end
                    end
                    r2_array = {this_period.locs(loc_ind, :).r2};
                    xx = iscellcontents(r2_array, @isempty);
                    r2_array(xx) = {nan};
                    legend(l, sprintfmulti('%s (R^2 = %.2f)', days_of_week, r2_array));
                    title(sprintf('%s, %s', periods_fns{i_period}, this_period.locs(loc_ind, 1).Location));
                end
                input('Press ENTER to continue','s');
                
                close(figs);
            end
        end
        
        function [is_diff, t_calc_all, t_table_all] = plot_diff_sig_grid(years, values, errors, dofs, varargin)
            % PLOT_DIFF_SIG_GRID(YEARS, VALUES, ERRORS, DOFS) Given the
            % values, errors, and numbers of degrees of freedom for values
            % for each year in YEARS, plot a grid indicating which
            % differences are significant. All inputs are numeric vectors.
            %
            % Parameters:
            %   'is_fit_good' - provide a vector the the same length as
            %   VALUES that is true for good fits, false for bad fits. Bad
            %   fits will not be included.
            %
            %   'parent' - axis to plot into. Set to false to not plot and
            %   just return the values.
            p = advInputParser;
            p.addOptional('is_fit_good', []);
            p.addParameter('parent', []);
            p.parse(varargin{:});
            pout = p.Results;
            
            is_fit_good = pout.is_fit_good;
            if isempty(is_fit_good)
                is_fit_good = true(size(values));
            end
            
            ax = pout.parent;
            do_plot = true;
            if isempty(ax)
                figure;
                ax = axes();
            elseif ~isgraphics(ax)
                do_plot = false;
            end
            
            n_yrs = numel(years);
            [year_y, year_x] = meshgrid(years, years);
            
            if size(errors,2) == 1
                % Allow symmetrical errors to be passed in and handled with the same
                % code as asymmetrical errors.
                errors = repmat(errors, 1, 2);
            end
            
            is_diff = nan(n_yrs, n_yrs);
            t_calc_all = nan(n_yrs, n_yrs);
            t_table_all = nan(n_yrs, n_yrs);
            for i_yr = 1:n_yrs
                for j_yr = (i_yr+1):n_yrs
                    yr_vals = values([i_yr, j_yr])';
                    if ~all(is_fit_good([i_yr, j_yr]))
                        % Assume that NaNs in the values mean that the result should be
                        % ignored.
                        continue
                    end
                    % We use a two-sided t-test because we aren't testing that one
                    % value is higher than another, we're testing if the two values are
                    % different, period.
                    %
                    % However, if the uncertainties are asymmetrical, we want to use
                    % the uncertainties that "face" each other, so if value1 < value2
                    % use the upper error for value2 and the lower error for value2, or
                    % vice verse.
                    if yr_vals(1) < yr_vals(2)
                        yr_err = [errors(i_yr, 2), errors(j_yr, 1)];
                    else
                        yr_err = [errors(i_yr, 1), errors(j_yr, 2)];
                    end
                    yr_dofs = dofs([i_yr, j_yr])';
                    [sig, t_calc, t_table] = misc_emissions_analysis.is_change_significant_alt(yr_vals, yr_err, yr_dofs);
                    
                    is_diff(i_yr, j_yr) = sig;
                    is_diff(j_yr, i_yr) = sig;
                    t_calc_all(i_yr, j_yr) = t_calc;
                    t_calc_all(j_yr, i_yr) = t_calc;
                    t_table_all(i_yr, j_yr) = t_table;
                    t_table_all(j_yr, i_yr) = t_table;
                end
            end
            
            if do_plot
                xx_yes = is_diff == 1;
                xx_no = is_diff == 0;
                line(ax, year_x(xx_yes), year_y(xx_yes), 'marker', 'o', 'color', [0 0.7 0], 'markersize', 10, 'markerfacecolor', [0 0.7 0], 'linestyle','none');
                line(ax, year_x(xx_no), year_y(xx_no), 'marker', 'x', 'color', 'r', 'markersize', 10, 'markerfacecolor', 'r', 'linestyle','none','linewidth',2);
                set(gca,'XTick',years,'YTick',years);
                xlim([years(1)-1, years(end)+1])
                ylim([years(1)-1, years(end)+1])
            end
        end
        
        function figs = plot_lifetime_vs_mass(varargin)
            % Plot lifetimes vs. some measure of NOx mass for each location
            % separately. Parameters:
            %   'loc_inds' - numeric indicies of which locations to
            %   include. May also be a cell array of location names.
            %
            %   'mass_value' - character array, either 'a' or 'vcds'.
            %   'a' uses the fitting parameter a, 'vcds' uses the
            %   average summer columns within the box width of the site.
            %
            %   'fit_type' - which EMG fitting method to use: 'lu' or
            %   'convolution'
            %
            %   'sat_or_model' - which data to use: 'BEHR' or 'WRF' (must
            %   be a cell array containing one or both of those).
            %
            %   'single_plot' - whether or not to plot all locations on one
            %   plot (boolean)
            %
            %   'single_plot_mode' - how to color the points in the single
            %   plot: 'Year' or 'HCHO VCD'
            %
            %   'norm_tau' - normalize lifetimes to each location's mean
            %   (boolean)
            %
            %   'window_width' - 1 or 3 year windows (number).
            %
            %   'years_to_plot' - what years to plot, must be a cell array
            %   of chars. If using window_width == 1, give the actual
            %   years. For window_width == 3, give the center years.
            %
            %   'days_of_week' - string or cell array of strings giving
            %   which days to plot out of U, M, T, W, R, F, S.
            %
            %   'connect_wkend' - whether or not to draw a line connecting
            %   weekday/weekend points for the same time period (boolean).
            %
            %   'bad_fit_display' - what to do with points whose fits fail
            %   the quality tests. Options are 'no' (do not display) or
            %   'grey' (grey out the points).
            %
            %   'legend' - which figures to include the legend on. Options
            %   are 'all', 'none', 'first', 'last'. ('first' and 'last' are
            %   only valid to 'single_plot' is false.)
            %
            %   'title' - include title on each plot. Default is true.
            E = JLLErrors;
            
            p = inputParser;
            p.addParameter('loc_inds', nan);
            p.addParameter('mass_value', '');
            p.addParameter('fit_type', '');
            p.addParameter('sat_or_model', {});
            p.addParameter('single_plot', nan);
            p.addParameter('single_plot_mode', '');
            p.addParameter('norm_tau', nan);
            p.addParameter('window_width', '');  % '1' or '3' - must be char
            p.addParameter('years_to_plot', {});  % must be cell array of chars
            p.addParameter('days_of_week', '');
            p.addParameter('connect_wkend', nan);
            p.addParameter('bad_fit_display','');
            p.addParameter('legend', '');
            p.addParameter('title', true); % if plotting interactively, we want the title. But provide the option to turn in off if not plotting interactively
            
            p.parse(varargin{:});
            pout = p.Results;
            
            include_title = pout.title;
            
            loc_inds = pout.loc_inds;
            file_loc_inds = 1:71;
            if iscell(loc_inds)
                loc_inds = misc_emissions_analysis.loc_names_to_inds(loc_inds{:});
            elseif isnan(loc_inds)
                [loc_inds, file_loc_inds] = misc_emissions_analysis.get_loc_inds_interactive();
            end
            
            mass_value = pout.mass_value;
            allowed_mass_vals = {'a','a_plus_B','vcds'};
            if isempty(mass_value)
                mass_value = ask_multichoice('Which quantity to use for mass of NOx?', allowed_mass_vals, 'list', true);
            elseif ~ismember(mass_value, allowed_mass_vals)
                E.badinput('MASS_VALUE must be one of: %s', strjoin(allowed_mass_vals, ', '));
            end
            
            window_width = misc_emissions_analysis.get_window_width(pout.window_width);
            if window_width == 1
                allowed_years = [2005, 2006, 2007, 2008, 2009, 2012, 2013, 2014];
                years_to_time_per_fxn = @(yrs) cellfun(@str2double, yrs, 'uniform', false);
            elseif window_width == 3
                allowed_years = [2006, 2007, 2008, 2010, 2011, 2012, 2013];
                years_to_time_per_fxn = @(yrs) cellfun(@(x) (str2double(x)-1):(str2double(x)+1), yrs, 'uniform', false);
            else
                E.notimplemented('Window width not 1')
            end           
            years_to_plot = opt_ask_multiselect('Which years to include?', cellfun(@num2str, num2cell(allowed_years), 'uniform', false), pout.years_to_plot, '"years_to_plot"');
            years_to_plot = years_to_time_per_fxn(years_to_plot);

            sat_or_model = opt_ask_multiselect('Which data source to use?', {'BEHR', 'WRF'}, pout.sat_or_model, '"sat_or_model"');
            
            single_plot_bool = opt_ask_yn('Plot all locations on a single plot?', pout.single_plot, '"single_plot"');
            if single_plot_bool
                single_plot_mode = opt_ask_multichoice('What should color represent in the plot?', {'Year','HCHO VCD'}, pout.single_plot_mode, '"single_plot_mode"', 'list', true);
            else
                single_plot_mode = '';
            end
            
            do_normalize_lifetimes = opt_ask_yn('Normalize lifetimes to mean of each location?', pout.norm_tau, '"norm_tau"');
            
            allowed_dows = {'UMTWRFS','TWRF','US'};
            days_of_week = opt_ask_multiselect('Choose which day-of-week subsets to include', [allowed_dows, 'all'], pout.days_of_week, '"days_of_week"');
            if strcmpi(days_of_week, 'all')
                days_of_week = allowed_dows;
            elseif ischar(days_of_week)
                days_of_week = {days_of_week};
            end
            
            do_connect_wkday_wkend = false;
            include_decade = ismember('UMTWRFS', days_of_week);
            include_wkday_wkend = all(ismember({'TWRF','US'}, days_of_week));
            include_behr = ismember('BEHR', sat_or_model);
            include_wrf = ismember('WRF', sat_or_model);
            if ~single_plot_bool
                if include_wkday_wkend
                    do_connect_wkday_wkend = opt_ask_yn('Connect weekday/weekend points?', pout.connect_wkend, '"connect_wkend"');
                elseif xor(ismember('TWRF', days_of_week), ismember('US', days_of_week))
                    E.notimplemented('For non-single plot mode, having one but not both of "TWRF" and "US" are not supported')
                end
                
                allowed_legend_figs = {'all', 'none', 'first', 'last'};
            else
                allowed_legend_figs = {'all', 'none'};
            end
            where_to_put_legend = opt_ask_multichoice('Where to include a legend?', allowed_legend_figs, pout.legend, '"legend"', 'list', true);
            
            bad_fit_display = opt_ask_multichoice('Plot bad fits?', {'no','grey'}, pout.bad_fit_display, '"bad_fit_display"', 'list', true');
            
            fit_type = misc_emissions_analysis.get_fit_type_interactive(pout.fit_type);
            
            locs = misc_emissions_analysis.read_locs_file();
            
            vcds_bool = strcmpi(mass_value, 'vcds');
            [~,~,~,wrf_file_inds] = misc_emissions_analysis.ask_to_use_wrf(true);
            
            % End input section %
            
            % These help keep the style consistent %
            marker_size = 10;
            marker_linewidth = 1.5;
            connector_linewidth = 2;
            dow_markers = misc_emissions_analysis.dow_markers;
            product_series = struct('behr', struct('used', false, 'name', 'BEHR', 'style', struct('marker', 'o', 'color', 'k', 'markerfacecolor', 'k', 'linestyle', 'none', 'linewidth', 2)),...
                'wrf', struct('used', false, 'name', 'WRF', 'style', struct('marker', 'o', 'color', 'k', 'linestyle','none','linewidth',2)));
            
            time_period_colors = misc_emissions_analysis.time_period_colors;
            % Now actually load the data
            
            all_changes = struct([]);
            if include_behr
                if include_decade
                    E.notimplemented('Decadal')
                end
                if include_wkday_wkend
                    for i_yr = 1:numel(years_to_plot)
                        load_change_group(years_to_plot{i_yr}, years_to_plot{i_yr}, 'TWRF', 'US', file_loc_inds);
                    end
                end
            end
            
            if include_wrf
                % WRF is only processed for all days because it cannot have
                % a weekend effect, since the NEI emissions are just a 24
                % hour cycle
                E.notimplemented('WRF')
            end
            
            if do_connect_wkday_wkend
                conn_fmt_fxn = @make_connector_fmt;
            else
                conn_fmt_fxn = @(x, y) struct('linestyle', 'none');
            end
            
            if vcds_bool
                x_label_str = 'Avg. NO_2 VCD (molec. cm^2)';
            else
                x_label_str = 'a (mol NO_2)';
            end
            
            if do_normalize_lifetimes
                % We want to normalize each city's lifetime by its average.
                for i_loc = 1:size(all_changes(1).tau)
                    loc_taus = nan(numel(all_changes), size(all_changes(1).tau,2));
                    for i_change = 1:numel(all_changes)
                        loc_taus(i_change,:) = all_changes(i_change).tau(i_loc, :);
                        % Don't include bad fits in the mean
                        loc_taus(i_change, ~all_changes(i_change).is_fit_good(i_loc, :)) = nan;
                    end
                    avg_tau = nanmean(loc_taus(:));
                    for i_change = 1:numel(all_changes)
                        all_changes(i_change).tau(i_loc,:) = all_changes(i_change).tau(i_loc,:) ./ avg_tau;
                    end
                end
            end
            
            if ~single_plot_bool
                figs = gobjects(numel(loc_inds),1);
                for i_loc = 1:numel(loc_inds)
                    figs(i_loc) = figure;
                    ax = gca;
                    for i_change = 1:numel(all_changes)
                        this_group_style = make_group_fmt(all_changes(i_change).style, all_changes(i_change).is_fit_good(i_loc, :));
                        this_connector_style = conn_fmt_fxn(all_changes(i_change).style, all_changes(i_change).is_significant(i_loc), all_changes(i_change).is_fit_good(i_loc,:));
                        plot_changes(all_changes(i_change).(mass_value)(i_loc,:), all_changes(i_change).tau(i_loc,:),...
                            'group_fmts', this_group_style, 'connector_fmt', this_connector_style, 'parent', ax);
                    end
                    
                    
                    if strcmpi(where_to_put_legend, 'all') || (strcmpi(where_to_put_legend, 'first') && i_loc == 1) || (strcmpi(where_to_put_legend, 'last') && i_loc == numel(loc_inds))
                        make_legend(ax);
                    end
                    if include_title
                        title(locs(loc_inds(i_loc)).Location);
                    end
                    
                    set(ax,'fontsize',16);
                    xlabel(x_label_str);
                    ylabel('\tau (hours)');
                end
            else
                l = gobjects(0);
                legend_cell = {};
                figure;
                if strcmpi(single_plot_mode, 'Year')
                    for i_change = 1:numel(all_changes)
                        line(all_changes(i_change).(mass_value)(:,1), all_changes(i_change).tau(:,1), all_changes(i_change).style(1));
                        line(all_changes(i_change).(mass_value)(:,2), all_changes(i_change).tau(:,2), all_changes(i_change).style(2));
                    end
                    legend_flags = {};
                elseif strcmpi(single_plot_mode, 'HCHO VCD')
                    is_wrf = [all_changes.is_wrf];
                    behr_no2_vcds = [all_changes(~is_wrf).(mass_value)];
                    behr_hcho_vcds = [all_changes(~is_wrf).hcho_vcds];
                    behr_tau = [all_changes(~is_wrf).tau];
                    scatter(behr_no2_vcds(:), behr_tau(:), 60, behr_hcho_vcds(:), 'filled');
                    
                    hold on
                    wrf_no2_vcds = [all_changes(is_wrf).(mass_value)];
                    wrf_hcho_vcds = [all_changes(is_wrf).hcho_vcds];
                    wrf_tau = [all_changes(is_wrf).tau];
                    scatter(wrf_no2_vcds(:), wrf_tau(:), 60, wrf_hcho_vcds(:));
                    
                    cb = colorbar;
                    cb.Label.String = 'HCHO VCD (molec. cm^{-2})';
                    colormap jet
                    legend_flags = {'no_dow', 'no_time_period'};
                end
                
                
                
                if strcmpi(where_to_put_legend, 'all')
                    make_legend(gca, legend_flags{:});
                end
                set(gca,'xscale','log','fontsize',14);
                xlabel(x_label_str);
                ylabel('\tau (hours)');
            end
            
            %                                                     %
            % Internal helper functions for plot_lifetime_vs_mass %
            %                                                     %
            
            function load_change_group(time_period_1, time_period_2, days_of_week_1, days_of_week_2, varargin)
                
                if numel(varargin) >= 1
                    load_loc_inds = varargin{1};
                else
                    load_loc_inds = 1:71;
                end
                
                if numel(varargin) >= 2
                    load_wrf = varargin{2};
                else
                    load_wrf = false;
                end
                
                if isnumeric(time_period_1)
                    tp1_field = sprintf('y%d', mean(time_period_1));
                else
                    tp1_field = time_period_1;
                end
                
                if isnumeric(time_period_2)
                    tp2_field = sprintf('y%d', mean(time_period_2));
                else
                    tp2_field = time_period_2;
                end
                
                if load_wrf
                    marker_fills = 'none';
                else
                    marker_fills = {time_period_colors.(tp1_field).color, time_period_colors.(tp2_field).color};
                end

                
                changes = misc_emissions_analysis.collect_changes(time_period_1, time_period_2, days_of_week_1, days_of_week_2, 'loc_inds', loc_inds, 'file_loc_inds', load_loc_inds, 'use_wrf', load_wrf, 'include_vcds', vcds_bool, 'fit_type', fit_type);
                %changes.is_significant = misc_emissions_analysis.is_change_significant(changes.tau, changes.tau_sd, changes.n_dofs);
                changes.style = struct('marker', {dow_markers.(days_of_week_1).marker, dow_markers.(days_of_week_2).marker},...
                    'linestyle', 'none', 'color', {time_period_colors.(tp1_field).color, time_period_colors.(tp2_field).color},...
                    'markersize',marker_size,'linewidth',marker_linewidth,'markerfacecolor',marker_fills);
                changes.is_wrf = load_wrf;
                dow_markers.(days_of_week_1).used = true;
                dow_markers.(days_of_week_2).used = true;
                if load_wrf
                    product_series.wrf.used = true;
                else
                    product_series.behr.used = true;
                end
                time_period_colors.(tp1_field).used = true;
                time_period_colors.(tp2_field).used = true;
                
                
                if isempty(all_changes)
                    all_changes = changes;
                else
                    all_changes(end+1) = changes;
                end
            end
            
            function make_legend(parent, varargin)
                subp = advInputParser;
                subp.addFlag('no_dow');
                subp.addFlag('no_time_period');
                subp.addFlag('no_product');
                
                subp.parse(varargin{:});
                sub_pout = subp.Results;
                
                no_days_of_week = sub_pout.no_dow;
                no_time_period = sub_pout.no_time_period;
                no_product = sub_pout.no_product;
                
                % first the time periods
                l = gobjects(0,1);
                legend_cell = {};
                if ~no_time_period
                    fns = fieldnames(time_period_colors);
                    for i_fn = 1:numel(fns)
                        this_tp = time_period_colors.(fns{i_fn});
                        if this_tp.used
                            l(end+1) = line(nan, nan, 'linewidth', connector_linewidth, 'color', this_tp.color, 'parent', parent);
                            legend_cell{end+1} = this_tp.name;
                        end
                    end
                end
                
                if ~no_days_of_week
                    fns = fieldnames(dow_markers);
                    for i_fn = 1:numel(fns)
                        this_dow = dow_markers.(fns{i_fn});
                        if this_dow.used
                            l(end+1) = line(nan,nan,'marker', this_dow.marker, 'linestyle', 'none', 'color', 'k', 'linewidth', marker_linewidth, 'markersize', marker_size, 'parent', parent);
                            legend_cell{end+1} = this_dow.name;
                        end
                    end
                end
                
                if ~no_product
                    fns = fieldnames(product_series);
                    which_products_used = nan(1, numel(fns));
                    for i_fn = 1:numel(fns)
                        which_products_used(i_fn) = product_series.(fns{i_fn}).used;
                    end
                    % We only want to indicate the different products in the
                    % legend if more than one was used, otherwise it is
                    % extraneous information
                    if sum(which_products_used) > 1
                        for i_fn = 1:numel(fns)
                            this_product = product_series.(fns{i_fn});
                            if this_product.used
                                l(end+1) = line(nan,nan,this_product.style);
                                legend_cell{end+1} = this_product.name;
                            end
                        end
                    end
                end
                
                if ~isempty(legend_cell)
                    legend(parent, l', legend_cell, 'location', 'best'); 
                end
            end
            
            function fmt = make_connector_fmt(group_fmt, is_change_sig, are_fits_good)
                these_time_period_colors = {group_fmt.color};
                
                if is_change_sig
                    linestyle = '-';
                else
                    linestyle = '--';
                end 
                
                if all(cellfun(@(x) isequal(x, these_time_period_colors{1}), these_time_period_colors))
                    connector_color = these_time_period_colors{1};
                else
                    connector_color = 'k';
                    % Quick kludge to avoid connecting all days-of-week
                    % points that don't have the same pairwise relationship
                    % that weekend-weekdays do. Since color == time period,
                    % if the colors differ, we don't connect.
                    linestyle = 'none';
                end
                
                % If one or both fits are bad, we should hide this line if
                % the plotting is set to not display bad fits, otherwise
                % leave it, since the point will be plotted in gray.
                if any(~are_fits_good)
                    if strcmpi(bad_fit_display, 'no')
                        linestyle = 'none';
                    else
                        linestyle = ':';
                    end
                end
                
                fmt = struct('color', connector_color, 'linestyle', linestyle, 'linewidth', connector_linewidth);
            end
            
            function group_fmt = make_group_fmt(group_fmt, are_fits_good)
                if strcmpi(bad_fit_display, 'no')
                    fmt_field = 'marker';
                    fmt_val = 'none';
                elseif any(strcmpi(bad_fit_display, {'grey','gray'}))
                    fmt_field = 'color';
                    fmt_val = [0.8 0.8 0.8];
                end
                
                if ~are_fits_good(1)
                    group_fmt(1).(fmt_field) = fmt_val;
                end
                if ~are_fits_good(2)
                    group_fmt(2).(fmt_field) = fmt_val;
                end
            end
            %     %
            % End %
            %     %
        end
        
        function [figs, x_vals, y, yerr] = plot_avg_lifetime_change(varargin)
            % PLOT_AVG_LIFETIME_CHANGE Plot how the average lifetime (and
            % other quantities) changed over time.
            %
            % Parameters:
            %   'locations' - see 'loc_inds' in class help
            %   'plot_quantity' - what to plot. May be:
            %       * 'Lifetime': plots the fitted lifetime
            %       * 'WRF Lifetime': plots the fitted lifetime from the
            %       WRF model
            %       * 'Weekend/weekday lifetime': plots the ratio of fitted
            %       weekend to weekday lifetime
            %       * 'Weekend - weekday lifetime': plots the difference of
            %       weekend and weekday lifetime
            %       * 'Emissions': plot emissions derived from the fits
            %       * 'VCDs': plot trends in NO2 VCDs
            %       * 'Winter VCDs': plot trends in winter BEHR NO2 VCDs
            %       * 'Weekend/weekday VCDs': plot ratio of weekend and
            %       weekday NO2 VCDs
            %       * 'Weekend - weekday VCDs': plot difference of weekend
            %       and weekday VCDs
            %       * 'Expected VCDs': plot the expected VCD trend from
            %       MOVES emissions and lifetime
            %
            %   'normalize' - set to true to normalize each value to the
            %   average of each location.
            %
            %   'plot_averaging' - how to average the plotted quantity:
            %       * 'None' - plot each location separately
            %       * 'Average' - plot the average of all locations
            %       * 'Median' - plot the median of all locations
            %       * 'VCD weighted avg.' - plot an averaged weighted by
            %       the VCDs at each location.
            %       * 'Boxplot' - make boxplots for each time period
            %       * 'Key years' - plot only the key years defined for
            %       each location in CITIES_LIFETIME_GROUPS.
            %
            %   'no_fig' - do not plot the figure, just return the data.
            %
            %   'allow_missing_vcds' - allow some years to be missing VCDs.
            %   (Should no longer be necessary).
            %
            %   'req_most' - set to true to limit the locations plotted to
            %   those with at most one bad fit.
            %
            %   'min_fits_req' - minimum number of good fits required for a
            %   city to be included. Default is 1. Overridden by 'req_most'
            %   when that is true.
            %
            %   'req_num_pts' - set to true to require >= 60 points in the
            %   line density.
            %
            %   'incl_err' - include error bars on the plot.
            %
            %   'ax' - an axis to plot in to.
            %
            % Many of these inputs will be interactively queried if not
            % given.
            E = JLLErrors;
            
            p = advInputParser;
            p.addParameter('locations', {});
            p.addParameter('plot_quantity', '');
            p.addParameter('normalize', nan);
            p.addParameter('plot_averaging', '');
            p.addParameter('always_restrict_to_moves', nan);
            p.addParameter('no_fig', false);
            p.addParameter('allow_missing_vcds', false);
            p.addParameter('exclude_bad_fits', true);
            p.addParameter('req_most', nan);
            p.addParameter('min_fits_req', 1);
            p.addParameter('req_num_pts', nan);
            p.addParameter('incl_err', nan);
            p.addParameter('use_nasa_vcds', false);
            p.addParameter('recalc_err', false);
            p.addParameter('ax',[]);
            p.addParameter('exclude',[]);
            p.parse(varargin{:});
            pout = p.Results;
            
            location_inds_or_names = pout.locations;
            do_plot_fig = ~pout.no_fig;
            allow_missing_vcds = pout.allow_missing_vcds;
            exclude_bad_fits = pout.exclude_bad_fits;
            use_nasa_vcds = pout.use_nasa_vcds;
            recalc_err = pout.recalc_err;
            exclude_inds = misc_emissions_analysis.convert_input_loc_inds(pout.exclude);
            ax = pout.ax;
            
            % options for the quantity to plot
            pqopts.lifetime = 'Lifetime';
            pqopts.wrf_lifetime = 'WRF Lifetime';
            pqopts.wkend_wkday_ratio = 'Weekend/weekday lifetime';
            pqopts.wkend_wkday_diff = 'Weekend - weekday lifetime';
            pqopts.emissions = 'Emissions';
            pqopts.moves = 'MOVES';
            pqopts.vcds = 'VCDs';
            pqopts.winter_vcds = 'Winter VCDs';
            pqopts.wkend_wkday_vcds_ratio = 'Weekend/weekday VCDs';
            pqopts.wkend_wkday_vcds_diff = 'Weekend - weekday VCDs';
            pqopts.expected_vcds = 'Expected VCDs';
            
            needs_moves = {pqopts.moves, pqopts.expected_vcds};
            
            plot_quantity = opt_ask_multichoice('Which quantity to plot?', struct2cell(pqopts), pout.plot_quantity, '"plot_quantity"', 'list', true);
            do_normalize = opt_ask_yn('Normalize each location''s value to its average?', pout.normalize', '"normalize"');
            
            if do_normalize
                ylabel_str = sprintf('Normalized %s', plot_quantity);
            else
                ylabel_str = plot_quantity;
            end
            
            % options for the averaging
            avgopts.none = 'None';
            avgopts.avg = 'Average';
            avgopts.median = 'Median';
            avgopts.vcdwt = 'VCD weighted avg.';
            avgopts.box = 'Boxplot';
            avgopts.keyyrs = 'Key years';
            
            plot_averaging = opt_ask_multichoice('What averaging to use?', struct2cell(avgopts), pout.plot_averaging, '"plot_averaging"', 'list', true);
            
            window_width = 3; % holdover from early work
            remove_decreasing_cities = false; % holdover from early work
            restrict_to_moves = opt_ask_yn('Only keep cities with MOVES data?', pout.always_restrict_to_moves, '"always_restrict_to_moves"');
            req_most_good_fits = opt_ask_yn('Only use cities with at most one bad fit?', pout.req_most, '"req_most"');
            req_num_pts = opt_ask_yn('Require line densities to have the ideal number of points?', pout.req_num_pts, '"req_num_pts"');
            include_err = opt_ask_yn('Include uncertainty on the plot?', pout.incl_err, '"incl_err"');
            
            req_n_fits = pout.min_fits_req;
            
            if window_width == 1
                years = {2005 2006 2007 2008 2009 2012 2013 2014};
                x_vals = cell2mat(years);
            elseif window_width == 3
                years = {2005:2007, 2006:2008, 2007:2009, 2008:2010, 2009:2011, 2010:2012, 2011:2013, 2012:2014};
                x_vals = [2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013];
            end
            
            n_years = numel(years);
            if strcmpi(plot_quantity, pqopts.wrf_lifetime)
                load_fxn = @load_wrf_tau;
            else
                load_fxn = @load_behr_tau;
            end
            
            for i_yr = 1:n_years
                % We'll need the fits in all cases to filter out
                % locations/times with bad fits
                
                fprintf('Loading %d\n', x_vals(i_yr));
                [week_locs, weekend_locs] = load_fxn(years{i_yr});
                
                
                %year_week_fits = load(misc_emissions_analysis.fits_file_name(sdates, edates, false, 1:71, 'TWRF', 'lu'));
                %year_weekend_fits = load(misc_emissions_analysis.fits_file_name(sdates, edates, false, 1:71, 'US', 'lu'));
                if isempty(location_inds_or_names)
                    xx = misc_emissions_analysis.loc_types_to_inds('Cities');
                else
                    xx = misc_emissions_analysis.convert_input_loc_inds(location_inds_or_names);
                end
                xx = xx(~ismember(xx, exclude_inds));
                week_locs = week_locs(xx);
                weekend_locs = weekend_locs(xx);
                
                if restrict_to_moves || ismember(plot_quantity, needs_moves)
                    week_locs = remove_locs_missing_county(week_locs);
                    weekend_locs = remove_locs_missing_county(weekend_locs);
                end
                
                if i_yr == 1
                    week_vals = nan(numel(week_locs), n_years);
                    weekend_vals = nan(numel(week_locs), n_years);
                    week_errs = nan(numel(week_locs), n_years);
                    weekend_errs = nan(numel(week_locs), n_years);
                    names = {week_locs.ShortName};
                    
                    % Load the VCDs once we have the lists of locations to
                    % read them in for. This subfunction loads all years so
                    % only need to do it once.
                    week_vcds = load_vcds(week_locs, 'TWRF');
                    weekend_vcds = load_vcds(weekend_locs, 'US');
                end
                clear year_fits
                
                for i_loc = 1:numel(week_locs)
                    if strcmpi(plot_quantity, pqopts.emissions)
                        this_week_val = week_locs(i_loc).emis_tau.emis;
                        this_week_err = week_locs(i_loc).emis_tau.emis_uncert;
                        this_weekend_val = weekend_locs(i_loc).emis_tau.emis;
                        this_weekend_err = weekend_locs(i_loc).emis_tau.emis_uncert;
                    elseif strcmpi(plot_quantity, pqopts.moves)
                        this_week_val = get_moves_for_loc_and_year(week_locs(i_loc), years{i_yr});
                        % MOVES doesn't have separate weekend values or
                        % errors
                        this_week_err = NaN;
                        this_weekend_val = NaN;
                        this_weekend_err = NaN;
                    elseif any(strcmpi(plot_quantity, {pqopts.vcds, pqopts.winter_vcds, pqopts.wkend_wkday_vcds_ratio, pqopts.wkend_wkday_vcds_diff}))
                        this_week_val = week_vcds(i_loc, i_yr);
                        this_week_err = NaN;
                        this_weekend_val = weekend_vcds(i_loc, i_yr);
                        this_weekend_err = NaN;
                    elseif strcmpi(plot_quantity, pqopts.expected_vcds)
                        moves_emis = get_moves_for_loc_and_year(week_locs(i_loc), years{i_yr});
                        behr_tau = week_locs(i_loc).emis_tau.tau;
                        this_week_val = moves_emis .* behr_tau;
                        this_week_err = NaN;
                        this_weekend_err = NaN;
                        % MOVES doesn't have separate weekend values
                        this_weekend_val = NaN;
                    else
                        this_week_val = week_locs(i_loc).emis_tau.tau;
                        this_weekend_val = weekend_locs(i_loc).emis_tau.tau;
                        this_week_err = week_locs(i_loc).emis_tau.tau_uncert;
                        this_weekend_err = weekend_locs(i_loc).emis_tau.tau_uncert;
                    end
                    
                    % Only add the value for this location/year if the fit
                    % worked (so the value is not empty)
                    if ~isempty(this_week_val)
                        week_vals(i_loc,i_yr) = this_week_val;
                        week_errs(i_loc, i_yr) = this_week_err;
                    end
                    if ~isempty(this_weekend_val)
                        weekend_vals(i_loc,i_yr) = this_weekend_val;
                        weekend_errs(i_loc,i_yr) = this_weekend_err;
                    end
                end
                
                if exclude_bad_fits
                    good_week_fits = misc_emissions_analysis.is_fit_good_by_loc(week_locs, 'DEBUG_LEVEL', 0, 'any_num_pts', ~req_num_pts);
                    good_weekend_fits = misc_emissions_analysis.is_fit_good_by_loc(weekend_locs, 'DEBUG_LEVEL', 0, 'any_num_pts', ~req_num_pts);
                else
                    good_week_fits = true(size(week_vals,1),1);
                    good_weekend_fits = true(size(weekend_vals,1),1);
                end
                
                week_vals(~good_week_fits,i_yr) = nan;
                week_errs(~good_week_fits,i_yr) = nan;
                week_vcds(~good_week_fits,i_yr) = nan;
                
                weekend_vals(~good_weekend_fits,i_yr) = nan;
                weekend_errs(~good_weekend_fits,i_yr) = nan;
                weekend_vcds(~good_weekend_fits,i_yr) = nan;
            end
            
            n_good_fits = sum(~isnan(week_vals),2);
            if req_most_good_fits
                good_for_trends = n_good_fits >= size(week_vals,2) - 1;
                if remove_decreasing_cities
                    good_for_trends = good_for_trends & ~all(diff(week_vals, 1, 2) < 0, 2);
                end
            else
                good_for_trends = n_good_fits >= req_n_fits;
            end

            week_vals = week_vals(good_for_trends, :);
            week_errs = week_errs(good_for_trends,:);
            week_vcds = week_vcds(good_for_trends, :);
            week_locs = week_locs(good_for_trends);
            weekend_vals = weekend_vals(good_for_trends, :);
            weekend_errs = weekend_errs(good_for_trends, :);
            weekend_vcds = weekend_vcds(good_for_trends, :);
            names = names(good_for_trends);
            
            
            plotting_fxn = @plot_envelope;
            reset_xlims = true;
            box_plotting_fxn = @(a,x,y,style,errs) boxplot(a, y, 'labels', x);
            
            lstyle = '';
            add_legend = false;
            
            switch plot_quantity
                case {pqopts.wkend_wkday_ratio, pqopts.wkend_wkday_vcds_ratio}
                    y = weekend_vals ./ week_vals;
                    yerr = y .* sqrt((weekend_errs ./ weekend_vals).^2 + (week_errs ./ week_vals).^2);
                case {pqopts.wkend_wkday_diff, pqopts.wkend_wkday_vcds_diff}
                    y = weekend_vals - week_vals;
                    yerr = sqrt(weekend_errs .^2 + week_errs.^2);
                otherwise
                    y = week_vals;
                    yerr = week_errs;
            end
            
            if do_normalize
                [y, yerr] = normalize_y(y, yerr);
            end
            
            
            
            switch plot_averaging
                case avgopts.none
                    lstyle = {'marker', 'o', 'linestyle', '-', 'linewidth', 2, 'markersize', 6};
                    add_legend = true;
                    plotting_fxn = @plot_ensemble;
                case avgopts.keyyrs
                    [y,yerr] = filter_to_key_years(y,yerr,week_locs);
                    lstyle = {'marker', 'd', 'linestyle', 'none', 'markersize', 6};
                    add_legend = true;
                    plotting_fxn = @(a,x,y,s,e) plot_ensemble(a,x,y,s,e,'filled');
                case avgopts.avg
                    yerr = nanstd(y, 0, 1);
                    y = nanmean(y, 1);
                    lstyle = {'linestyle', '-', 'linewidth', 3, 'color', 'k'};
                case avgopts.median
                    yerr = quantile(y,[0.25 0.75],1);
                    y = nanmedian(y,1);
                    yerr = abs(yerr - repmat(y, 2, 1));
                    lstyle = {'linestyle', '-', 'linewidth', 3, 'color', 'k'};
                case avgopts.vcdwt
                    [y, yerr] = weighted_mean(y, week_vcds, 1);
                    lstyle = 'bo';
                case avgopts.box
                    plotting_fxn = box_plotting_fxn;
                    % box plots don't have the same xlimits as the others
                    reset_xlims = false;
            end
            
            if ~include_err
                yerr = [];
            end
            
            if do_plot_fig
                if isempty(ax)
                    figs = figure;
                    ax = gca;
                    figs.Position(3) = figs.Position(3) * 1.3;
                else
                    figs = ax.Parent;
                end
                h = plotting_fxn(ax, x_vals, y, lstyle, yerr);
                if add_legend
                    legend(h, names{:}, 'location', 'eastoutside')
                end
                ylabel(plot_quantity)
                if reset_xlims
                    xlim([min(x_vals)-1, max(x_vals)+1]);
                end
            else
                figs = gobjects(0);
            end
            
            function [ynorm, yerrnorm] = normalize_y(taus, tau_errs)
                % Find the average for each location across all years, then
                % normalize each location to its own average.
                ybar = repmat(nanmean(taus,2), 1, n_years);
                ynorm = taus ./ ybar;
                % When multiplying a value by a constant, its uncertainty
                % gets multiplied by the same constant
                yerrnorm = tau_errs ./ ybar;
            end
            
            function vcds = load_vcds(locs, days_of_week)
                if use_nasa_vcds
                    vcd_specie = 'nasa_no2';
                else
                    vcd_specie = 'no2';
                end
                
                if regcmpi(plot_quantity, pqopts.winter_vcds)
                    season = 'winter';
                else
                    season = 'summer';
                end
                vcds = nan(numel(locs), n_years);
                for i_yr_inner = 1:n_years
                    vcds(:,i_yr_inner) = misc_emissions_analysis.avg_vcds_around_loc(locs, years{i_yr_inner},...
                        days_of_week, 'species', vcd_specie, 'season', season, 'ignore_missing_files', allow_missing_vcds);
                end
            end
            
            function l = plot_ensemble(ax, x, y, style, varargin)
                plocal = advInputParser;
                plocal.addOptional('errs', []);
                plocal.addFlag('filled');
                plocal.parse(varargin{:});
                pout_local = plocal.Results;
                
                errs = pout_local.errs;
                fill_markers = pout_local.filled;
                
                n = size(y,1);
                n_not_nan = sum(~isnan(y),1);
                tot_not_nan = cumsum(~isnan(y),1);
                
                l = gobjects(n,1);
                for i=1:n
                    max_offset = min(0.3, floor(n_not_nan/2)*0.1);
                    step = 2*max_offset ./ max(n_not_nan-1,1);
                    offsets = -max_offset + max(0, tot_not_nan(i,:)-1) .* step;
                    if isvector(x)
                        x_plot = x + offsets;
                    else
                        x_plot = x(i,:) + offsets;
                    end
                    
                    if isempty(errs)
                        err_plot = [];
                    else
                        err_plot = squeeze(errs(i,:,:));
                        if isrow(err_plot)
                            err_plot = err_plot';
                        end
                    end
                    
                    color = map2colmap(i,1,n,'jet');
                    if fill_markers
                        extra_args = {'markerfacecolor', color};
                    else
                        extra_args = {};
                    end
                    
                    l(i) = line(x_plot,y(i,:),'color',color,style{:},extra_args{:}, 'parent', ax);
                    if isempty(err_plot)
                    elseif size(err_plot,2) == 1
                        scatter_errorbars(x_plot, y(i,:), err_plot', 'color', color, 'parent', ax);
                    else
                        scatter_errorbars(x_plot, y(i,:), err_plot(:,1)', err_plot(:,2)', 'color', color, 'parent', ax);
                    end
                end
            end
            
            function l = plot_envelope(ax, x, y, style, varargin)
                plocal = advInputParser;
                plocal.addOptional('errs', []);
                plocal.parse(varargin{:});
                pout_local = plocal.Results;
                
                errs = pout_local.errs;
                i_col = strcmpi(style, 'color');
                if sum(i_col) == 1
                    color = style{find(i_col)+1};
                else
                    color = 'b';
                end
                if size(errs,1) == 1
                    plot_error_envelope_y(x, y-errs, y+errs, color);
                elseif size(errs,1) == 2
                    plot_error_envelope_y(x, y-errs(1,:), y+errs(2,:), color);
                end % if errs is empty, do not plot them
                l = line(ax, x, y, style{:});
            end
            
            function locs = remove_locs_missing_county(locs)
                xx_loc = true(size(locs));
                for i=1:numel(locs)
                    xx_loc(i) = ~isnan(locs(i).CoreCountyID);
                end
                locs = locs(xx_loc);
            end
            
            function moves = get_moves_for_loc_and_year(loc, yr)
                if window_width == 3
                    yr = yr(2);
                end
                moves_table = misc_emissions_analysis.read_moves_data(...
                    'locations', loc, 'window_width', window_width, 'years', yr, 'months', 4:9);
                if size(moves_table,1) ~= 1
                    E.notimplemented('Getting multiple years of MOVES at once')
                else
                    moves = moves_table{1,'emis'};
                end
            end
            
            function [y,yerr] = filter_to_key_years(y,yerr,locs)
                for i = 1:numel(locs)
                    key_yrs = cities_lifetime_groups.get_key_years(locs(i).ShortName, 'TWRF');
                    iyrs = ismember(x_vals, key_yrs);
                    y(i,~iyrs) = nan;
                    yerr(i,~iyrs) = nan;
                end
            end
            
            function [locs_wkday, locs_wkend] = load_behr_tau(this_year_window)
                [sdates, edates] = misc_emissions_analysis.select_start_end_dates(this_year_window);
                oh_data = load(misc_emissions_analysis.oh_file_name(sdates, edates));
                locs_wkday = misc_emissions_analysis.append_new_spreadsheet_fields(oh_data.locs_wkday);
                locs_wkend = misc_emissions_analysis.append_new_spreadsheet_fields(oh_data.locs_wkend);
                if recalc_err
                    locs_wkday = misc_emissions_analysis.recalc_tau_uncertainty(locs_wkday);
                    locs_wkend = misc_emissions_analysis.recalc_tau_uncertainty(locs_wkend);
                end
            end
            
            function [locs_wkday, locs_wkend] = load_wrf_tau(this_year_window)
                fits = load(misc_emissions_analysis.wrf_fit_file_name(this_year_window, 'no2_vcds'));
                locs_wkday = fits.locs;
                locs_wkend = fits.locs; % WRF doesn't have a weekday/weekend cycle
            end
        end
        
        function [fig, ratio, ratio_std, ratio_n] = plot_no2_hcho_vcds_by_group(varargin)
            % PLOT_NO2_HCHO_VCDS_BY_GROUP Plot ratio of HCHO to NO2 VCDs for
            % each of the four groups of cities (decreasing, increasing,
            % CCD and CCU).
            %
            % Returns the figure handle, and (if plot_mode is a timeseries
            % one) the HCHO:NO2 ratios, standard deviations, and number of
            % points as cell arrays (decreasing, increasing, ccup, and
            % ccdown).
            %
            % Parameters:
            %   'radius' - radius (in degrees) to averaged VCDs from around
            %   the city. Default ('by_loc') determines this from the line
            %   density box size.
            %
            %   'plot_mode' - what kind of plot to make:
            %       * 'scatter' plots HCHO on the y-axis and NO2 on the
            %       x-axis.
            %       * 'timeser' plots the HCHO/NO2 ratio as a time series.
            %       * 'scatter-avg', 'timeser-avg' same as above except
            %       uses the group average, rather than individual cities.
            %
            %   'filter_fit' - whether or not to remove cities if their
            %   weekday lifetime fit is bad. 0 disables this, 1 only
            %   removes it when the fit is bad. >=2 requires that a city
            %   have that many good years to be kept, but if kept, is
            %   kept for all years.
            
            p = advInputParser;
            p.addParameter('radius', 'by_loc');
            p.addParameter('no2_type', 'behr');
            p.addParameter('plot_mode', 'timeser-avg'); % 'scatter', 'scatter-avg', 'timeser', or 'timeser-avg'
            p.addParameter('filter_fit', 0);
            p.addParameter('ax', []);
            p.parse(varargin{:});
            pout = p.Results;
            
            plot_mode = pout.plot_mode;
            no2_type = pout.no2_type;
            vcd_radius = pout.radius;
            do_filter_fit = pout.filter_fit;
            ax = pout.ax;
            
            if isempty(ax)
                fig = figure;
                ax = gca;
            else
                fig = ax.Parent;
            end
            
            if strcmpi(no2_type, 'nasa')
                no2_specie = 'nasa_no2';
            else
                no2_specie = 'no2';
            end
            
            cities = cell(1,4);
            cities_names = {'Decreasing', 'Increasing', 'CCU', 'CCD'};
            cities{1} = cities_lifetime_groups.decr_lifetime;
            cities{2} = cities_lifetime_groups.incr_lifetime;
            cities{3} = cities_lifetime_groups.ccup_lifetime;
            cities{4} = cities_lifetime_groups.ccdown_lifetime;
            
            colors = {'k','b',[0 0.5 0],'r'};
            switch lower(plot_mode)
                case 'scatter'
                    linestyle = '-';
                    xlabel_str = 'NO_2 VCDs (molec. cm^{-2})';
                    ylabel_str = 'HCHO VCDs (molec. cm^{-2})';
                case 'scatter-avg'
                    linestyle = 'none';
                    xlabel_str = 'NO_2 VCDs (molec. cm^{-2})';
                    ylabel_str = 'HCHO VCDs (molec. cm^{-2})';
                case {'timeser','timeser-avg'}
                    linestyle = '-';
                    xlabel_str = '';
                    ylabel_str = 'HCHO VCDs / NO_2 VCDs';
                otherwise
                    error('No linestyle defined for plot mode == "%s"', plot_mode)
            end
            group_styles = struct('marker', {'o','d','v','^'}, 'color', colors, 'markerfacecolor', colors, 'linestyle', linestyle);
            group_jitter = [-0.15, -0.05, 0.05, 0.15];
            locs = misc_emissions_analysis.read_locs_file();
            locs = locs(misc_emissions_analysis.get_loc_inds_of_type('Cities'));
            years = 2006:2013;
            
            proto_arr = {nan(numel(years), numel(locs))};
            no2 = repmat(proto_arr, size(cities));
            hcho = repmat(proto_arr, size(cities));
            names = cell(1,4);
            
            % If filtering on good fits, we need to go through and load
            % them first to figure out which cities to keep. When not
            % filtering, just pretend all fits are good for simplicity.
            
            good_fits = misc_emissions_analysis.create_fit_filter_vecs(do_filter_fit, years);
            good_fits = good_fits(:, 1:numel(locs));
           
            
            for iyr = 1:numel(years)
                yr = years(iyr);
                yr_win = (yr-1):(yr+1);
                
                no2_avgs = misc_emissions_analysis.avg_vcds_around_loc(locs,yr_win,'TWRF','species',no2_specie,'radius',vcd_radius);
                hcho_avgs = misc_emissions_analysis.avg_vcds_around_loc(locs,yr_win,'TWRF','species','hcho','radius',vcd_radius);
                no2_avgs(~good_fits(iyr, :)) = nan;
                hcho_avgs(~good_fits(iyr, :)) = nan;
                
                for i_grp = 1:numel(cities)
                    loc_inds = misc_emissions_analysis.convert_input_loc_inds(cities{i_grp});
                    if iyr == 1
                        no2{i_grp} = no2{i_grp}(:, loc_inds);
                        hcho{i_grp} = hcho{i_grp}(:, loc_inds);
                    end
                    no2{i_grp}(iyr, :) = no2_avgs(loc_inds);
                    hcho{i_grp}(iyr, :) = hcho_avgs(loc_inds);
                    names{i_grp} = {locs(loc_inds).ShortName};
                end
            end
            
            
            lall = gobjects(numel(cities),1);
            plot_err = false;
            add_city_names = false;
            
            ratio = cell(size(no2));
            ratio_std = cell(size(no2));
            ratio_n = cell(size(no2));
            for i_grp = 1:numel(cities)
                if regcmpi(plot_mode, '^scatter')
                    if regcmpi(plot_mode, 'avg$')
                        no2{i_grp} = nanmean(no2{i_grp}, 1);
                        hcho{i_grp} = nanmean(hcho{i_grp}, 1);
                    end
                    % If plotting unaveraged points, will get an array of lines. Just keep
                    % the first one for the legend.
                    l = line(ax, no2{i_grp}, hcho{i_grp}, group_styles(i_grp));
                    lall(i_grp) = l(1);
                elseif regcmpi(plot_mode, '^timeser')
                    this_ration = hcho{i_grp} ./ no2{i_grp};
                    if regcmpi(plot_mode, 'avg$')
                        %ratio(ratio<0) = nan;
                        ratio_n{i_grp} = sum(~isnan(this_ration), 2);
                        ratio_std{i_grp} = nanstd(this_ration, [], 2);
                        ratio{i_grp} = nanmean(this_ration, 2);
                        plot_err = true;
                        x = years + group_jitter(i_grp);
                    else
                        ratio_n = ones(size(this_ration));
                        ratio_std = nan(size(this_ration));
                        add_city_names = true;
                        x = years;
                    end
                    l = line(ax, x, ratio{i_grp}, group_styles(i_grp));
                    if plot_err
                        scatter_errorbars(x, ratio{i_grp}, ratio_std{i_grp}, 'color', group_styles(i_grp).color, 'parent', ax)
                    elseif add_city_names
                        for i_city = 1:length(names{i_grp})
                            city_x = i_grp + 2013*ones(size(names{i_grp}));
                            city_y = ratio{i_grp}(end,:);
                            text(city_x, city_y, names{i_grp}, 'color', group_styles(i_grp).color, 'parent', ax);
                        end
                    end
                    lall(i_grp) = l(1);
                end
            end
            legend(lall, cities_names);
            xlabel(xlabel_str);
            ylabel(ylabel_str);
            if add_city_names
                set(gca, 'xlim', [2005 2020], 'xtick', 2006:2013)
            end
        end
        
        function plot_hcho_no2_ratio_sig(varargin)
            args = update_params(varargin, 'plot_mode', 'timeser-avg');
            [fig, ratios, ratio_stds, ratio_ns] = misc_emissions_analysis.plot_no2_hcho_vcds_by_group(args{:});
            % each of the outputs should be a cell array with each cell
            % being a group of cities and a column vector of values per 
            % year.
            ratios = cat(2, ratios{:});
            ratio_stds = cat(2, ratio_stds{:});
            ratio_ns = cat(2, ratio_ns{:});
            names = {'Decr.', 'Incr', 'CCU', 'CCD'};
            
            n_groups = size(ratios, 2);
            n_years = size(ratios, 1);
            close(fig);
            fig = figure;
            
            [yticks, xticks] = meshgrid(1:n_groups, 1:n_groups);
            years = 2006:2013;
            if numel(years) ~= n_years
                error('Different number of years than expected');
            end
            
            for iyr = 1:n_years
                these_ratios = ratios(iyr, :);
                these_stds = ratio_stds(iyr, :);
                these_ns = ratio_ns(iyr, :);
                
                is_diff = false(n_groups, n_groups);
                for i = 1:n_groups
                    for j = (i+1):n_groups
                        [~, ~, d] = two_sample_t_test_alt(these_ratios(i), these_stds(i), these_ns(i), these_ratios(j), these_stds(j), these_ns(j));
                        is_diff(i,j) = d;
                        is_diff(j,i) = d;
                    end
                end
                
                ax = subplot(2, 4, iyr);
                line(xticks(is_diff), yticks(is_diff), 'marker', 'o', 'color', [0 0.5 0], 'linewidth', 2, 'linestyle', 'none');
                line(xticks(~is_diff), yticks(~is_diff), 'marker', 'x', 'color', 'r', 'linewidth', 2, 'linestyle', 'none');
                set(ax, 'xtick', 1:4, 'xticklabels', names, 'ytick', 1:4, 'yticklabels', names);
                title(ax, sprintf('%d', years(iyr)));
            end
            
            subplot_stretch(2,4);
        end
        
        function plot_vcd_trends_by_radius(varargin)
            %UNTITLED Summary of this function goes here
            %   Detailed explanation goes here
            
            p = advInputParser;
            p.addParameter('filter_flag', 0, @(x) x >= 0);
            p.addParameter('specie', 'no2');
            p.addParameter('days_of_week', 'TWRF', @(x) ismember(x, 'TWRF', 'US'));
            
            p.parse(varargin{:});
            pout = p.Results;
            
            filter_flag = pout.filter_flag;
            days_of_week = pout.days_of_week;
            vcd_specie = pout.specie;
            
            years = 2006:2013;
            radii = [0, 25, 50, 75, 100]/111;  % roughly convert kilometers into degrees.
            midpoints = 0.5 * (radii(1:end-1) + radii(2:end));
            n_rad = numel(radii) - 1;
            good_fits = misc_emissions_analysis.create_fit_filter_vecs(filter_flag, years);
            
            locs = misc_emissions_analysis.read_locs_file();
            loc_inds = 1:49;%misc_emissions_analysis.loc_types_to_inds('Cities');
            locs = locs(loc_inds);
            good_fits = good_fits(:, loc_inds);
            
            vcds = nan([size(good_fits), n_rad]);
            
            for iyr = 1:numel(years)
                for irad = 1:n_rad
                    yr_win = (years(iyr)-1):(years(iyr)+1);
                    inner = radii(irad);
                    outer = radii(irad+1);
                    these_vcds = misc_emissions_analysis.avg_vcds_around_loc(locs, yr_win, days_of_week,...
                        'species', vcd_specie, 'radius', outer, 'inner_rad', inner);
                    these_vcds(~good_fits(iyr, :)) = nan;
                    vcds(iyr, :, irad) = these_vcds;
                end
            end
            
            % For each group of cities, get the average by year and radius, then plot
            % VCD vs. distance, colored by time.
            cities = cell(1,4);
            cities_names = {'Decreasing', 'Increasing', 'CCU', 'CCD'};
            cities{1} = cities_lifetime_groups.decr_lifetime;
            cities{2} = cities_lifetime_groups.incr_lifetime;
            cities{3} = cities_lifetime_groups.ccup_lifetime;
            cities{4} = cities_lifetime_groups.ccdown_lifetime;
            
            fig = figure;
            
            for i_grp = 1:numel(cities)
                ax = subplot(2, 2, i_grp);
                grp_inds = misc_emissions_analysis.convert_input_loc_inds(cities{i_grp});
                grp_vcds = squeeze(nanmean(vcds(:, grp_inds, :), 2));
                for iyr = 1:numel(years)
                    color = map2colmap(iyr, 1, numel(years), 'jet');
                    line(midpoints, grp_vcds(iyr, :), 'color', color, 'marker', 'o');
                end
                
                colorbar;
                caxis([min(years), max(years)]);
                colormap('jet');
                title(ax, cities_names{i_grp});
            end
            
            subplot_stretch(2,2);
            
        end


        function [figs] = plot_loc_vcd_diff_maps(varargin)
            %UNTITLED Summary of this function goes here
            %   Detailed explanation goes here
            
            p = advInputParser;
            p.addParameter('key_years', [2006, 2010, 2013]);
            p.addParameter('days_of_week', 'TWRF');
            p.addParameter('loc_inds', 1:49);
            p.addParameter('season', 'summer');
            
            p.parse(varargin{:});
            pout = p.Results;
            
            key_years = pout.key_years;
            loc_inds =  misc_emissions_analysis.convert_input_loc_inds(pout.loc_inds);
            days_of_week = pout.days_of_week;
            season = pout.season;
            
            % Load the VCDs for each of the three year periods
            nlocs = numel(loc_inds);
            nyears = numel(key_years);
            vcds = cell(size(key_years));
            
            for iyr = 1:nyears
                yr = key_years(iyr);
                yr_win = (yr-1):(yr+1);
                vcd_struct = misc_emissions_analysis.load_vcds_for_years(yr_win, days_of_week, 'season', season);
                
                % lon and lat should be the same for all years
                lon = vcd_struct.lon;
                lat = vcd_struct.lat;
                vcds{iyr} = vcd_struct.daily_vcds;
            end
            
            locs = misc_emissions_analysis.read_locs_file();
            locs = locs(loc_inds);
            
            figs = gobjects(nlocs,1);
            for iloc = 1:nlocs
                figs(iloc) = figure;
                this_loc = locs(iloc);
                
                % assuming the grid cells are all 0.05 deg, this will get the right
                % radius in # of boxes
                radius = nanmean(this_loc.BoxSize(3:4))/0.05;
                [xx,yy] = misc_emissions_analysis.find_indicies_in_box_around_point(this_loc, lon, lat, radius);
                
                abs_axes = cell(nyears,1);
                diff_axes = cell(nyears-1,1);
                max_vcd = 0;
                max_diff = 0;
                
                for iyr = 1:nyears
                    yr = key_years(iyr);
                    yr_win = (yr-1):(yr+1);
                    ax = subplot(2, nyears, iyr);
                    abs_axes{iyr} = ax;
                    these_vcds = vcds{iyr}(xx,yy);
                    pcolor(ax, lon(xx, yy), lat(xx,yy), these_vcds);
                    shading flat
                    colorbar
                    if nanmax(these_vcds(:)) > max_vcd
                        max_vcd = nanmax(these_vcds(:));
                    end
                    
                    title(ax, sprintf('%s: %s', this_loc.Location, sprintf_ranges(yr_win)));
                    
                    if iyr > 1
                        ax = subplot(2, nyears, iyr+nyears);
                        diff_axes{iyr-1} = ax;
                        these_diffs = vcds{iyr}(xx,yy) - vcds{iyr-1}(xx,yy);
                        pcolor(ax, lon(xx, yy), lat(xx, yy), these_diffs);
                        shading flat
                        colormap(ax, blue_red_cmap);
                        colorbar
                        this_max = nanmax(abs(these_diffs(:)));
                        if this_max > max_diff
                            max_diff = this_max;
                        end
                        title(ax, sprintf('%d* vs. %d*', key_years(iyr), key_years(iyr-1)));
                        
                    else
                        
                    end
                end
                
                max_vcd = ceil(max_vcd/5e14)*5e14;
                max_diff = ceil(max_diff/5e14)*5e14;
                
                for iax = 1:numel(abs_axes)
                    caxis(abs_axes{iax}, [0, max_vcd]);
                end
                
                for iax = 1:numel(diff_axes)
                    caxis(diff_axes{iax}, [-max_diff, max_diff]);
                end
                
                subplot_stretch(2, nyears, 'figh', figs(iloc));
            end
            
        end


        

        function make_t_score_table(csv_file, dow)
            years = 2006:2013;
            cities = cell(4,1);
            cities{1} = cities_lifetime_groups.decr_lifetime;
            cities{2} = cities_lifetime_groups.incr_lifetime;
            cities{3} = cities_lifetime_groups.ccup_lifetime;
            cities{4} = cities_lifetime_groups.ccdown_lifetime;
            cities = sort(veccat(cities{:}));
            cities_inds = misc_emissions_analysis.convert_input_loc_inds(cities);
            
            n_years = numel(years);
            n_locs = numel(cities);
            
            taus = nan(n_years, n_locs);
            tau_errors = nan(n_years, n_locs);
            tau_dofs = nan(n_years, n_locs);
            fits_good_any_num = false(n_years, n_locs);
            t_calc = nan(n_years, n_years, n_locs);
            t_table = nan(n_years, n_years, n_locs);
            
            for i_yr = 1:n_years
                yr = years(i_yr);
                yr_win = (yr-1):(yr+1);
                fprintf('Working on %s\n', sprintf_ranges(yr_win));
                
                fits = load(misc_emissions_analysis.behr_fit_file_name(yr_win, dow));
                locs = misc_emissions_analysis.cutdown_locs_by_index(fits.locs, cities_inds);
                
                for i_loc = 1:n_locs
                    taus(i_yr, i_loc) = get_tau(locs(i_loc).emis_tau.tau);
                    tau_errors(i_yr, i_loc) = get_tau(locs(i_loc).emis_tau.tau_uncert);
                    tau_dofs(i_yr, i_loc) = get_tau(locs(i_loc).emis_tau.n_dofs);

                    fits_good_any_num(i_yr, i_loc) = misc_emissions_analysis.is_fit_good_by_loc(locs(i_loc), 'any_num_pts', true, 'DEBUG_LEVEL', 1);
                end
            end
            
            for i_loc = 1:n_locs
                [~, t_calc(:, :, i_loc), t_table(:, :, i_loc)] = misc_emissions_analysis.plot_diff_sig_grid(years, taus(:, i_loc), tau_errors(:, i_loc), tau_dofs(:, i_loc), fits_good_any_num(:, i_loc), 'parent', false);
            end
            
            fid = fopen(csv_file, 'w');
            fprintf(fid, 'City,Years,tcalc,ttable,Years,tcalc,ttable\n');
            for i_city = 1:numel(cities)
                this_city = cities{i_city};
                key_yrs = cities_lifetime_groups.get_key_years(this_city, dow);
                key_yr_inds = year_inds(key_yrs);
                line_cell = {this_city, '', '', '', '', '', ''};
                for i_yr = 1:(numel(key_yrs)-1)
                    yridx = key_yr_inds(i_yr:i_yr+1);
                    this_t_calc = t_calc(yridx(1), yridx(2), i_city);
                    this_t_table = t_table(yridx(1), yridx(2), i_city);
                    
                    if isnan(this_t_calc) || isnan(this_t_table)
                        error('Got NaN t values')
                    end
                    
                    i_cell = (i_yr-1)*3+2;
                    line_cell{i_cell} = sprintf('%d->%d', key_yrs(i_yr), key_yrs(i_yr+1));
                    line_cell{i_cell+1} = sprintf('%.2f', this_t_calc);
                    line_cell{i_cell+2} = sprintf('%.2f', this_t_table);
                end
                
                fprintf(fid, '%s\n', strjoin(line_cell, ','));
            end
            fclose(fid);
            
            function tau = get_tau(tau)
                if isempty(tau)
                    tau = NaN;
                end
            end
            
            function inds = year_inds(key_yrs)
                inds = nan(size(key_yrs));
                for iy = 1:numel(key_yrs)
                    inds(iy) = find(years == key_yrs(iy));
                end
            end
        end
        
        function figs = plot_lifetime_with_sig(varargin)
            % PLOT_LIFETIME_WITH_SIG Plot weekday and weekend lifetimes for
            % locations along with grids showing which lifetimes are
            % significantly different from one another.
            %
            % Parameters:
            %   'loc_inds' - see class help
            %
            %   'product' - 'behr' (for satellite-derived lifetimes) or
            %   'wrf' (for model lifetimes)
            p = advInputParser;
            p.addParameter('loc_inds', 1:71);
            p.addParameter('product', 'behr');
            p.addParameter('hide_bad_fits', false);
            p.addParameter('recalc_err', false);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            loc_inds = misc_emissions_analysis.convert_input_loc_inds(pout.loc_inds);
            hide_bad_fits = pout.hide_bad_fits;
            data_product = pout.product;
            recalc_err = pout.recalc_err;
            
            if strcmpi(data_product, 'behr')
                name_fxn = @(yrs, dow) misc_emissions_analysis.behr_fit_file_name(yrs, dow);
            elseif strcmpi(data_product, 'nasa')
                name_fxn = @(yrs, dow) misc_emissions_analysis.nasa_fit_file_name(yrs, dow);
            elseif strcmpi(data_product, 'wrf')
                name_fxn = @(yrs, dow) misc_emissions_analysis.wrf_fit_file_name(yrs, 'no2_vcds', 'TWRF');
            else
                error('Data product "%s" not recognized', data_product);
            end
            
            years = 2006:2013;
            locs = misc_emissions_analysis.cutdown_locs_by_index(misc_emissions_analysis.read_locs_file(), loc_inds);
            
            n_years = numel(years);
            n_locs = numel(locs);
            n_dows = 2;
            
            taus = nan(n_years, n_locs, n_dows);
            tau_errors = nan(n_years, n_locs, n_dows);
            tau_dofs = nan(n_years, n_locs, n_dows);
            fits_good = false(n_years, n_locs, n_dows);
            fits_good_any_num = false(n_years, n_locs, n_dows);
            for i_yr = 1:n_years
                yr = years(i_yr);
                yr_win = (yr-1):(yr+1);
                fprintf('Working on %s\n', sprintf_ranges(yr_win));
                
                wkdays = load(name_fxn(yr_win, 'TWRF'));
                wkdays.locs = misc_emissions_analysis.cutdown_locs_by_index(wkdays.locs, loc_inds);
                wkends = load(name_fxn(yr_win, 'US'));
                wkends.locs = misc_emissions_analysis.cutdown_locs_by_index(wkends.locs, loc_inds);
                
                if recalc_err
                    wkdays.locs = misc_emissions_analysis.recalc_tau_uncertainty(wkdays.locs);
                    wkends.locs = misc_emissions_analysis.recalc_tau_uncertainty(wkends.locs);
                end
                
                for i_loc = 1:n_locs
                    taus(i_yr, i_loc, 1) = get_tau(wkdays.locs(i_loc).emis_tau.tau);
                    taus(i_yr, i_loc, 2) = get_tau(wkends.locs(i_loc).emis_tau.tau);
                    tau_errors(i_yr, i_loc, 1) = get_tau(wkdays.locs(i_loc).emis_tau.tau_uncert);
                    tau_errors(i_yr, i_loc, 2) = get_tau(wkends.locs(i_loc).emis_tau.tau_uncert);
                    tau_dofs(i_yr, i_loc, 1) = get_tau(wkdays.locs(i_loc).emis_tau.n_dofs);
                    tau_dofs(i_yr, i_loc, 2) = get_tau(wkends.locs(i_loc).emis_tau.n_dofs);
                    fits_good(i_yr, i_loc, 1) = misc_emissions_analysis.is_fit_good_by_loc(wkdays.locs(i_loc), 'DEBUG_LEVEL', 0);
                    fits_good(i_yr, i_loc, 2) = misc_emissions_analysis.is_fit_good_by_loc(wkends.locs(i_loc), 'DEBUG_LEVEL', 0);
                    fits_good_any_num(i_yr, i_loc, 1) = misc_emissions_analysis.is_fit_good_by_loc(wkdays.locs(i_loc), 'any_num_pts', true, 'DEBUG_LEVEL', 1);
                    fits_good_any_num(i_yr, i_loc, 2) = misc_emissions_analysis.is_fit_good_by_loc(wkends.locs(i_loc), 'any_num_pts', true, 'DEBUG_LEVEL', 1);
                end
            end
            
            figs = gobjects(n_locs,1);
            for i_loc = 1:n_locs
                loc_name = locs(i_loc).ShortName;
                figs(i_loc) = figure;
                ax=subplot(2,2,1);
                plot_lifetimes(ax, years, taus(:, i_loc, 1), tau_errors(:, i_loc, 1), fits_good(:, i_loc, 1), fits_good_any_num(:, i_loc, 1));
                title(sprintf('%s %s Weekdays', loc_name, upper(data_product)));
                
                ax=subplot(2,2,2);
                misc_emissions_analysis.plot_diff_sig_grid(years, taus(:, i_loc, 1), tau_errors(:, i_loc, 1), tau_dofs(:, i_loc, 1), fits_good_any_num(:, i_loc, 1), 'parent', ax);
                title(sprintf('%s %s Weekdays', loc_name, upper(data_product)));
                
                ax=subplot(2,2,3);
                plot_lifetimes(ax, years, taus(:, i_loc, 2), tau_errors(:, i_loc, 2), fits_good(:, i_loc, 2), fits_good_any_num(:, i_loc, 2));
                title(sprintf('%s %s Weekends', loc_name, upper(data_product)));
                
                ax=subplot(2,2,4);
                misc_emissions_analysis.plot_diff_sig_grid(years, taus(:, i_loc, 2), tau_errors(:, i_loc, 2), tau_dofs(:, i_loc, 2), fits_good_any_num(:, i_loc, 2), 'parent', ax);
                title(sprintf('%s %s Weekends', loc_name, upper(data_product)));
                
                subplot_stretch(2,2);
            end
            
            function plot_lifetimes(ax, years, tau, tau_err, is_good, is_good_any_num)
                line(ax, years(is_good), tau(is_good), 'color', [0 0.5 0], 'marker', 'o', 'markersize', 8, 'markerfacecolor', [0 0.5 0], 'linestyle', 'none');
                scatter_errorbars(years(is_good), tau(is_good), tau_err(is_good), 'color', [0 0.5 0], 'linewidth', 2, 'parent', ax);
                
                xx = is_good_any_num & ~is_good;
                line(ax, years(xx), tau(xx), 'color', [0.75 0.75 0], 'marker', 'o', 'markersize', 8, 'markerfacecolor', [0.75 0.75 0], 'linestyle', 'none');
                scatter_errorbars(years(xx), tau(xx), tau_err(xx), 'color', [0.75 0.75 0], 'linewidth', 2, 'parent', ax);
                
                if ~hide_bad_fits
                    line(ax, years(~is_good_any_num), tau(~is_good_any_num), 'color', 'r', 'marker', 'x', 'markersize', 8, 'linewidth', 2, 'linestyle', 'none');
                    scatter_errorbars(years(~is_good_any_num), tau(~is_good_any_num), tau_err(~is_good_any_num), 'color', 'r', 'linewidth', 2, 'parent', ax);
                end
            end
            
            function tau = get_tau(tau)
                if isempty(tau)
                    tau = NaN;
                end
            end
            
        end

        function fig = plot_lifetime_map(varargin)
            %PLOT_LIFETIME_MAP Plot a map of how lifetimes changed for all
            %cities in the four well-defined groups.
            %
            %Parameters:
            %   'plot_type' - 'diff' (default) plots a single plot of the
            %   difference in lifetimes, 'before-after' plots two panels,
            %   one at the beginning and the other at the end of the
            %   record.
            
            p = advInputParser;
            p.addParameter('plot_type', 'diff');
            
            p.parse(varargin{:});
            pout = p.Results;
            
            plot_type = pout.plot_type;
            
            time_periods = {2005:2007, 2012:2014};
            fits = cell(size(time_periods));
            n_times = numel(time_periods);
            
            for i_time = 1:n_times
                these_fits = load(misc_emissions_analysis.behr_fit_file_name(time_periods{i_time}, 'TWRF'));
                fits{i_time} = these_fits.locs;
            end
            
            proto_array = nan(size(fits{1}));
            lons = cat(1, fits{1}.Longitude);
            lats = cat(1, fits{1}.Latitude);
            lifetimes1 = proto_array;
            lifetimes2 = proto_array;
            
            for i_loc = 1:numel(fits{1})
                tau1 = fits{1}(i_loc).emis_tau.tau;
                if ~isempty(tau1)
                    lifetimes1(i_loc) = tau1;
                end
                tau2 = fits{2}(i_loc).emis_tau.tau;
                if ~isempty(tau2)
                    lifetimes2(i_loc) = tau2;
                end
            end
            
            fig = figure;
            switch lower(plot_type)
                case 'diff'
                    ax = gca;
                    plot_lifetimes(ax, lons, lats, lifetimes2 - lifetimes1, '\Delta \tau (2013-2006, h)');
                    caxis(calc_plot_limits(lifetimes2 - lifetimes1, 'diff')/2);
                    colormap(blue_red_cmap)
                case 'before-after'
                    ax(1) = subplot(2,1,1);
                    plot_lifetimes(ax(1), lons, lats, lifetimes1, 'NO_x \tau (2006, h)');
                    ax(2) = subplot(2,1,2);
                    plot_lifetimes(ax(2), lons, lats, lifetimes2, 'NO_x \tau (2013, h)');
                    subplot_stretch(2,1);
                    clims = calc_plot_limits(veccat(lifetimes1, lifetimes2)/2);
                    caxis(ax(1), clims);
                    caxis(ax(2), clims);
                otherwise
                    error('plot_type "%s" not recognized', plot_type)
            end
            
            function plot_lifetimes(ax, lons, lats, lifetimes, cb_label)
                hold on
                cities = {cities_lifetime_groups.decr_lifetime,...
                    cities_lifetime_groups.incr_lifetime,...
                    cities_lifetime_groups.ccdown_lifetime,...
                    cities_lifetime_groups.ccup_lifetime};
                markers = {'v', '^', 'd', 'o'};
                l = gobjects(numel(cities), 1);
                for i_grp = 1:numel(cities)
                    xx = misc_emissions_analysis.convert_input_loc_inds(cities{i_grp});
                    scatter(ax, lons(xx), lats(xx), 36, lifetimes(xx), markers{i_grp}, 'filled', 'markeredgecolor', 'k');
                    l(i_grp) = line(nan,nan,'marker',markers{i_grp},'linestyle','none','color','k');
                end
                state_outlines('k');
                cb = colorbar;
                cb.Label.String = cb_label;
                legend(l, {'Decreasing', 'Increasing', 'CCD', 'CCU'}, 'location', 'northwest');
                xlim([-125 -065]);
                ylim([25 50]);
            end
            
        end
        
        function plot_box_city_group_vcds(varargin)
            p = advInputParser;
            p.addParameter('groups', {'decr', 'incr', 'ccu', 'ccd'});
            p.addParameter('exclude', []);
            
            p.parse(varargin{:});
            pout = p.Results;
            groups = pout.groups;
            
            group_cities = struct('decr', {cities_lifetime_groups.decr_lifetime},...
                'incr', {cities_lifetime_groups.incr_lifetime},...
                'ccu', {cities_lifetime_groups.ccup_lifetime},...
                'ccd', {cities_lifetime_groups.ccdown_lifetime});
            group_colors = struct('decr', 'k', 'incr', 'b', 'ccu', [0 0.5 0], 'ccd', 'r');
            group_labels = struct('decr', 'Decr.', 'incr', 'Incr.', 'ccu', 'CCU', 'ccd', 'CCD');
            
            exclude_inds = misc_emissions_analysis.convert_input_loc_inds(pout.exclude);
            
            ngrp = numel(groups);
            l = gobjects(ngrp, 1);
            width = 0.6 / ngrp;
            offsets = linspace(-0.3, 0.3, ngrp);
            labels = cell(1, ngrp);
            
            fig = figure;
            ax = gca;
            hold on
            
            for igr = 1:numel(groups)
                thisg = groups{igr};
                grp_inds = misc_emissions_analysis.convert_input_loc_inds(group_cities.(thisg));
                grp_inds = grp_inds(~ismember(grp_inds, exclude_inds));
                [~, years, vcds] = misc_emissions_analysis.plot_avg_lifetime_change('locations', grp_inds, ...
                    'plot_quantity', 'VCDs', 'normalize', false, 'plot_averaging', 'None', ...
                    'no_fig', true, 'req_most', false, 'min_fits_req', 3, 'req_num_pts', false,...
                    'incl_err', false, 'always_restrict_to_moves', false);
                %years = 2006:2013;
                %vcds = 9e15*rand(10, length(years));
                
                col = group_colors.(thisg);
                boxplot(ax, vcds, 'positions', years + offsets(igr), 'labels', years, 'widths', width, 'colors', col, 'symbol', '+');
                l(igr) = line([nan, nan], [nan, nan], 'color', col, 'linewidth', 2);
                labels{igr} = group_labels.(thisg);
            end
            
            legend(l, labels);
            ylabel('VCD (molec. cm^{-2})');
            set(gca, 'xlim', [2005 2014], 'ylim', [0 1e16], 'xtick', years, 'fontsize', 14, 'xticklabelrotation', 30);
            grid on
        end


        
        function [figs, info] = plot_vcd_vs_concentration(varargin)
            % This plots the surface or boundary layer concentration
            % inferred from average WRF-Chem profiles vs. BEHR VCDs. We
            % will assume that the WRF-Chem profiles are representative of
            % the all days-of-week average VCDs (since the NEI emissions do
            % not have a weekend effect, I'm not sure at the moment if they
            % represent an average of all days or are a representative
            % weekday inventory). So to get at the TWRF and US VCD ->
            % concentrations, we'll interpolate the NO2 profiles by their
            % corresponding VCDs.
            
            error('This function is out of date and needs upgraded to work with the three year numeric time periods')
            
            p = advInputParser;
            p.addParameter('loc_indices', 1:71);
            p.addParameter('interp_method', 'linear');
            p.addParameter('conc_type', 'boundary layer');
            
            p.parse(varargin{:});
            pout = p.Results;
            
            loc_ind = pout.loc_indices;
            interp_method = pout.interp_method;
            conc_type = pout.conc_type;
            
            locs = misc_emissions_analysis.read_locs_file;
            % Since we're reading the locations directly from the
            % spreadsheet, rather than a .mat file, we can cut it down
            % directly.
            locs = locs(loc_ind);
            
            time_periods = {'beg_2yr','beginning','end_2yr','end'};
            days_of_week = {'UMTWRFS', 'TWRF', 'US'};
            
            n_time = numel(time_periods);
            n_dow = numel(days_of_week);
            n_locs = numel(locs);
            n_levels = [];
            
            vcds = cell(n_time, n_dow);
            profs = cell(n_time, n_dow);
            pres = cell(n_time, n_dow);
            
            for i_time = 1:n_time
                [profs{i_time, 1}, pres{i_time, 1}] = misc_emissions_analysis.avg_wrf_prof_around_loc(locs, time_periods{i_time}, 'nox_or_no2', 'nox', 'radius', 0.35);
                for i_dow = 1:n_dow
                    vcds{i_time, i_dow} = misc_emissions_analysis.avg_vcds_around_loc(locs, time_periods{i_time}, days_of_week{i_dow}, 'radius', 0.35);
                    if i_dow > 1
                        profs{i_time, i_dow} = nan(size(profs{i_time, 1}));
                        pres{i_time, i_dow} = nan(size(pres{i_time, 1}));
                    end
                end
                
                if isempty(n_levels)
                    n_levels = size(profs{i_time, 1},1);
                else
                    if size(profs{i_time, 1}, 1) ~= n_levels
                        error('Different numbers of levels')
                    end
                end
            end
            
            % Now we handle the interpolation and at the same time
            % calculate the concentration, either averaged over the
            % boundary layer or right at the surface
            base_dow_ind = 1;
            concentrations = cell(size(vcds));
            concentrations(:) = {nan(1, n_locs)};
            figs = gobjects(n_locs,1);
            
            dow_markers = misc_emissions_analysis.dow_markers;
            time_period_colors = misc_emissions_analysis.time_period_colors;
            
            for i_loc = 1:n_locs
                figs(i_loc) = figure;
                loc_vcds = cellfun(@(v) v(i_loc), vcds);
                loc_base_sfs = nan(n_levels, n_time);
                %loc_base_pres = nan(n_levels, n_time);
                for i_time = 1:n_time
                    loc_base_sfs(:, i_time) = profs{i_time, base_dow_ind}(:, i_loc);
                    %loc_base_pres(:, i_time) = pres{i_time, base_dow_ind}(:, i_loc);
                end
                
                % For the days-of-week that we haven't declared equivalent
                % to WRF, we need to interpolate to get their shape factors
                for i_time = 1:n_time
                    for i_dow = 1:n_dow
                        if i_dow == base_dow_ind
                            this_prof = profs{i_time, i_dow}(:, i_loc);
                            %this_pres = pres{i_time, i_dow}(:, i_loc);
                        else
                            this_prof = interp_profiles(loc_vcds(:, base_dow_ind), loc_base_sfs, loc_vcds(i_time, i_dow), interp_method);
                            %this_pres = interp_profiles(loc_vcds(:, base_dow_ind), loc_base_pres, loc_vcds(i_time, i_dow), 'nearest');
                        end
                        
                        nox_conc_prof = this_prof .* loc_vcds(i_time, i_dow);
                        if strcmpi(conc_type, 'boundary layer')
                            concentrations{i_time, i_dow}(i_loc) = avg_bl_conc(nox_conc_prof);
                        elseif strcmpi(conc_type, 'surface')
                            concentrations{i_time, i_dow}(i_loc) = nox_conc_prof(1);
                        end
                        
                        marker = dow_markers.(days_of_week{i_dow}).marker;
                        color = time_period_colors.(time_periods{i_time}).color;
                        line(loc_vcds(i_time, i_dow), concentrations{i_time, i_dow}(i_loc), 'color', color, 'marker', marker, 'linestyle', 'none', 'linewidth', 2, 'markersize', 16);
                    end
                end
                
                info.concentrations = concentrations;
                info.vcds = vcds;
                info.locs = locs;
                
            end
            
            function interp_profs = interp_profiles(base_vcds, base_profs, target_vcds, method)
                interp_profs = nan(size(base_profs,1), 1);
                for i_lev = 1:numel(interp_profs)
                    interp_profs(i_lev) = interp1(base_vcds, base_profs(i_lev, :), target_vcds, method, 'extrap');
                end
            end
            
            function conc = avg_bl_conc(nox_prof)
                % Assume the first ~10 model levels are in the BL, based on
                % Chicago
                conc = nanmean(nox_prof(1:10));
            end
        end
        
        function plot_wind_distribution(varargin)
            % Plot the distribution of winds in the 8 direction bins for a
            % given location.
            p = inputParser;
            p.addParameter('winds_file','');
            p.addParameter('all_winds', nan);
            p.addParameter('loc_inds',nan);
            p.addParameter('as_fraction',nan);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            use_all_winds = pout.all_winds;
            winds_file = pout.winds_file;
            loc_inds = pout.loc_inds;
            as_fraction = pout.as_fraction;
            
            if isempty(winds_file)
                winds_file = misc_emissions_analysis.get_line_dens_file_interactive();
            end
            
            if isnan(use_all_winds)
                use_all_winds = ask_yn('Use all winds (not just those actually used by calc_line_density)?');
            end
            
            if isnan(loc_inds)
                loc_inds = misc_emissions_analysis.get_loc_inds_interactive();
            end
            
            if isnan(as_fraction)
                as_fraction = ask_yn('Plot bins as fraction (rather than counts)?');
            end
            
            speed_cutoff = 3;
            locs_slow = misc_emissions_analysis.bin_wind_distribution(winds_file, 'all_winds', use_all_winds, 'loc_inds', loc_inds, 'wind_op','lt','wind_speed',speed_cutoff);
            locs_fast = misc_emissions_analysis.bin_wind_distribution(winds_file, 'all_winds', use_all_winds, 'loc_inds', loc_inds, 'wind_op','gt','wind_speed',speed_cutoff);
            
            for i_loc = 1:numel(locs_slow)
                y_val_fast = locs_fast(i_loc).WindDirBinCounts;
                y_val_slow = locs_slow(i_loc).WindDirBinCounts;
                x_val = locs_fast(i_loc).WindDirBinCenters; % this should be the same in both
                y_label_string = '# orbits';
                if as_fraction
                    y_val_fast = y_val_fast ./ sum(locs_fast(i_loc).WindDirBinCounts);
                    y_val_slow = y_val_slow ./ sum(locs_slow(i_loc).WindDirBinCounts);
                    y_label_string = 'Fraction of orbits';
                end
                
                [~,~,~,fit_data] = calc_fit_line(y_val_slow, y_val_fast, 'regression', 'RMA');
                
                figure;
                plot(x_val, y_val_slow, 'bo', x_val, y_val_fast, 'rx');
                legend(sprintf('Wind speed < %d', speed_cutoff), sprintf('Wind speed > %d', speed_cutoff));
                xlabel('Wind direction (degrees CCW of east)');
                ylabel(y_label_string);
                title(locs_fast(i_loc).Location);
                x_limits = get(gca,'xlim');
                y_limits = get(gca,'ylim');
                text(interp1([0 1], x_limits, 0.8), interp1([0 1], y_limits, 0.8), sprintf('R^2 = %.2f', fit_data.R2), 'fontsize', 16);
            end
            
        end
        
        function [wind_bin_weights, wind_bin_edges] = calculate_wind_bin_weights(locs, wind_speed, varargin)
            % CALCULATE_WIND_BIN_WEIGHTS Calculates weights for the eight
            % different wind direction bins used in an attempt to apply Liu
            % 16's (www.atmos-chem-phys.net/16/5283/2016/) method of
            % convolving the slow line densities with an exponential to
            % account for downwind sources.
            E = JLLErrors;
            p = inputParser;
            p.addParameter('all_winds', false);
            p.addParameter('bin_width',45);
            p.parse(varargin{:});
            pout = p.Results;
            
            use_all_winds = pout.all_winds;
            bin_width = pout.bin_width;
            
            wind_bin_weights = cell(size(locs));
            wind_bin_edges = cell(size(locs));
            for i_loc = 1:numel(locs)
                % include 'loc_inds' = [] to indicate that we do not want
                % to cut down the locations at all.
                locs_tmp = misc_emissions_analysis.bin_wind_distribution(locs(i_loc), 'all_winds', use_all_winds, 'loc_inds', [], 'wind_op', 'lt', 'wind_speed', wind_speed, 'bin_width', bin_width);
                slow_wind_counts = locs_tmp.WindDirBinCounts;
                locs_tmp = misc_emissions_analysis.bin_wind_distribution(locs(i_loc), 'all_winds', use_all_winds, 'loc_inds', [], 'wind_op', 'gt', 'wind_speed', wind_speed, 'bin_width', bin_width);
                fast_wind_counts = locs_tmp.WindDirBinCounts;
                wind_bin_edges{i_loc} = locs_tmp.WindDirBinEdges;
                
                wind_bin_weights{i_loc} = fast_wind_counts ./ slow_wind_counts;
            end
            
            
        end
        
        function locs = bin_wind_distribution(winds_file, varargin)
            % BIN_WIND_DISTRIBUTION Bin the occurrences of wind directions
            %   BIN_WIND_DISTRIBUTION( WINDS_FILE ) Given a file name as a
            %   char array, will load the file WINDS_FILE and try to bin
            %   the data within it. The file must contain a structure
            %   called "locs" with fields "WindDir" and "WindSpeed".
            %   Alternately, give the locs structure contained in such a
            %   file as WINDS_FILE directly. Returns the locs structure
            %   with the fields "WindDirBinCounts", "WindDirBinEdges", and
            %   "WindDirBinCenters" fields added.
            %
            %   Parameters:
            %       'all_winds' - boolean, whether to include only winds
            %       for orbits used by calc_line_density() (false, default)
            %       or all winds (true). If false, then the locs structure
            %       in the winds file must also contain the field
            %       "WindUsedBool"
            %
            %       'loc_inds' - a logical or numeric index array to cut
            %       down the locs structure to only relevant locations.
            %       Asked interactively if omitted (or given as NaN).
            %
            %       'wind_op' - either the string 'lt' or 'gt' to indicate
            %       whether only winds less than or greater than the
            %       criterion speed should be used. Asked interactively if
            %       omitted.
            %
            %       'wind_speed' - the wind speed criterion (in
            %       meters/second) that goes along with 'wind_op'. Asked
            %       interactively if omitted.
            %
            %       'bin_width' - the width of the bins in degrees. Default
            %       is 45.
            E = JLLErrors;
            p = inputParser;
            p.addParameter('all_winds', false);
            p.addParameter('loc_inds',nan);
            p.addParameter('wind_op','');
            p.addParameter('wind_speed',[]);
            p.addParameter('bin_width',45);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            use_all_winds = pout.all_winds;
            loc_inds = pout.loc_inds;
            wind_op = pout.wind_op;
            wind_speed = pout.wind_speed;
            bin_width = pout.bin_width;
            
            if ischar(winds_file)
                W = load(winds_file);
                locs = W.locs;
            elseif isstruct(winds_file)
                locs = winds_file;
            end
            if any(~isfield(locs, {'WindSpeed','WindDir'}))
                E.badinput('The file "%s" does not appear to have the expected wind data', winds_file);
            end
            
            if ~use_all_winds && ~isfield(locs, 'WindUsedBool')
                if ischar(winds_file)
                    msg = sprintf('The file "%s" does not contain the field "WindUsedBool" in the locs structure. Pass "''all_wind'', true" if you need to bin a file that does not have this field', winds_file);
                else
                    msg = 'The given structure does not contain the field "WindUsedBool". Pass "''all_wind'', true" if you need to bin a file that does not have this field';
                end
                E.callError('missing_wind_used', msg)
            end
            
            if isnan(loc_inds)
                loc_inds = misc_emissions_analysis.get_loc_inds_interactive();
            end
            if ~isempty(loc_inds)
                locs = misc_emissions_analysis.cutdown_locs_by_index(locs, loc_inds);
            end
            
            if ~isnumeric(bin_width) || ~isscalar(bin_width) || bin_width <= 0
                E.badinput('''bin_width'' must be a positive scalar number');
            end
            
            [wind_op, wind_speed] = misc_emissions_analysis.choose_wind_criteria(wind_op, wind_speed);
            
            % TODO: find a way to extract winds actually used in the
            % analysis, i.e. those that match up with BEHR swaths that have
            % actual data
            for i_loc = 1:numel(locs)
                winds_logical = misc_emissions_analysis.set_wind_conditions(locs(i_loc),wind_speed,wind_op,'none');
                if ~use_all_winds
                    winds_logical = winds_logical & locs(i_loc).WindUsedBool;
                end
                all_wind_directions = locs(i_loc).WindDir(winds_logical);
                [bin_counts, bin_edges] = histcounts(all_wind_directions, -180:bin_width:180);
                locs(i_loc).WindDirBinCounts = bin_counts;
                locs(i_loc).WindDirBinEdges = bin_edges;
                locs(i_loc).WindDirBinCenters = 0.5*(bin_edges(1:end-1)+bin_edges(2:end));
            end
            
        end
        
        function plot_loc_wind_rose(varargin)
            % PLOT_LOC_WIND_ROSE Plot a wind rose for a given location
            % Parameters:
            %   'time_period' - see class help
            %   'loc_inds' - see class help
            %   'wind_op' - 'gt' or 'lt' for greater or less then the...
            %   'wind_speed' - wind speed in m/s that winds must be greater
            %   or less than (based on wind_op) to be included.
            %   'convert_wind_def' - if true, winds are plotted in the
            %   traditional way where the wind rose gives directions the
            %   winds are coming from. Set to false to plot where the winds
            %   are blowing towards.
            %   'keep_rejected_direction' - set to true to include wind
            %   directions normally ignored for each location.
            %
            % Any parameters not given will be queried interactively.
            E=JLLErrors;
            p = inputParser;
            p.addParameter('time_period', '');
            p.addParameter('loc_inds', nan);
            p.addParameter('wind_op','');
            p.addParameter('wind_speed',[]);
            p.addParameter('convert_wind_def', true);
            p.addParameter('keep_rejected_directions', nan);
            p.addParameter('use_wrf', nan);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            time_period = pout.time_period;
            loc_inds = pout.loc_inds;
            wind_op = pout.wind_op;
            wind_speed = pout.wind_speed;
            convert_wind_def_bool = pout.convert_wind_def;
            keep_rejected_directions_bool = pout.keep_rejected_directions;
            use_wrf = pout.use_wrf;
            
            [start_dates, end_dates] = misc_emissions_analysis.select_start_end_dates(time_period);
            winds_file = misc_emissions_analysis.winds_file_name(start_dates{1}, end_dates{end});
            W = load(winds_file);
            W.locs = misc_emissions_analysis.append_new_spreadsheet_fields(W.locs);
            
            if isnan(loc_inds)
                loc_inds = misc_emissions_analysis.get_loc_inds_interactive();
            end
            if ~isempty(loc_inds)
                W.locs = misc_emissions_analysis.cutdown_locs_by_index(W.locs, loc_inds);
            end
            
            [wind_op, wind_speed] = misc_emissions_analysis.choose_wind_criteria(wind_op, wind_speed);
            
            if isnan(keep_rejected_directions_bool)
                keep_rejected_directions_bool = ask_yn('Retain rejected wind directions for the wind rose?');
            end
            
            if ~keep_rejected_directions_bool
                [~, ~, wind_rej_field] = misc_emissions_analysis.ask_to_use_wrf(use_wrf);
            else
                wind_rej_field = 'none';
            end
            
            
            for i_loc = 1:numel(W.locs)
                winds_logical = misc_emissions_analysis.set_wind_conditions(W.locs(i_loc), wind_speed, wind_op, wind_rej_field);
                wind_dir = W.locs.WindDir(winds_logical);
                wind_vel = W.locs.WindSpeed(winds_logical);
                if convert_wind_def_bool
                    % In my scheme, a wind direction of 0 degrees means the
                    % wind is blowing to the east, 90 means to the north,
                    % 180 to the west, and -90 to the south. Since a wind
                    % rose traditionally represents the direction that the
                    % wind is coming from, we need to flip this. That means
                    % a wind coming from the north is blowing to the south,
                    % so in my definition a northerly wind has an angle of
                    % -90. An easterly has an angle of +/- 180 in my
                    % definition.
                    north_angle = -90;
                    east_angle = -180;
                else
                    north_angle = 90;
                    east_angle = 0;
                    fprintf('!!! NOTE: wind rose plotting directions winds are blowing TOWARDS !!!\n');
                end
                
                % Wind rose automatically creates a new figure
                WindRose(wind_dir, wind_vel, 'anglenorth', north_angle, 'angleeast', east_angle);
            end
        end
        
        function save_tables()
            % Save the tables generated by
            % TABLUATE_PARAMETER_CORRELATION().
            time_periods = {'beg_2yr', 'beginning', 'end_2yr', 'end'};
            req_values = {'FitAccepted', 'Correlation', 'FracPtsBiasedWindow10', 'FracPtsBiasedWindow20', 'LifetimesDownwind', 'R2', 'Tau', 'TauPercentUncertainty', 'E', 'EPercentUncertainty'};
            
            common_opts = {'time_periods', time_periods, 'values', req_values};
            BEHRTables = misc_emissions_analysis.tabulate_parameter_correlation(common_opts{:}, 'days_of_week', {'UMTWRFS','TWRF','US'}, 'data', 'BEHR');
            WRFTables = misc_emissions_analysis.tabulate_parameter_correlation(common_opts{:}, 'days_of_week', {'UMTWRFS'}, 'data', 'BEHR');
            savename = fullfile(misc_emissions_analysis.table_dir, sprintf('Tables%s.mat', datestr(today, 'yyyymmdd')));
            save(savename, 'BEHRTables', 'WRFTables');
        end
        
        function output_tables = tabulate_parameter_correlation(varargin)
            % Make tables of the correlation between different parameters
            % from the fits. NOTE: this function is outdated as written.
            E = JLLErrors;
            p = advInputParser;
            p.addParameter('time_periods', {});
            p.addParameter('days_of_week', {});
            p.addParameter('data', '')
            p.addParameter('values', {});
            
            p.parse(varargin{:});
            pout = p.Results;
            
            error('This function is outdated. It needs updated to work with the new method of specifying time periods as numbers')
            
            quantity_fxns = struct('Correlation', @calc_correlation,...
                'FitAccepted', @(this_loc) misc_emissions_analysis.is_fit_good_by_loc(this_loc),...
                'R2', @(this_loc) this_loc.fit_info.param_stats.r2,...
                'FracPtsBiasedWindow10', @(this_loc) mean(misc_emissions_analysis.test_fit_for_bias(this_loc.no2_sectors.linedens, this_loc.fit_info.emgfit, 'window', 10)),...
                'FracPtsBiasedWindow20', @(this_loc) mean(misc_emissions_analysis.test_fit_for_bias(this_loc.no2_sectors.linedens, this_loc.fit_info.emgfit, 'window', 20)),...
                'LifetimesDownwind', @(this_loc) misc_emissions_analysis.n_lifetimes_downwind(this_loc.no2_sectors.x, this_loc.fit_info.ffit.x_0, this_loc.fit_info.ffit.mu_x),...
                'E', @(this_loc) this_loc.emis_tau.emis,...
                'EPercentUncertainty', @(this_loc) this_loc.emis_tau.emis_uncert / this_loc.emis_tau.emis * 100,...
                'Tau', @(this_loc) this_loc.emis_tau.tau,...
                'TauPercentUncertainty', @(this_loc) this_loc.emis_tau.tau_uncert / this_loc.emis_tau.tau * 100);
            
            avail_time_periods = {'beg_2yr', 'beginning', 'end_2yr', 'end'};
            time_periods = opt_ask_multiselect('Which time periods to include?', avail_time_periods, pout.time_periods, '"time_periods"');
            days_of_week = opt_ask_multiselect('Which days-of-week to include?', {'UMTWRFS','TWRF','US'}, pout.days_of_week, '"days_of_week"');
            data_source = opt_ask_multichoice('Which data set to use?', {'BEHR', 'WRF'}, pout.data, '"data"', 'list', true);
            requested_values = opt_ask_multiselect('Which values to tabulate?', fieldnames(quantity_fxns), pout.values, '"values"');
            requested_values = cellfun(@capitalize_words, requested_values, 'uniform', false);
            requested_values = regexprep(requested_values, '\s', '');
            
            wrf_bool = strcmpi(data_source, 'WRF');
            ss_locs = misc_emissions_analysis.read_locs_file('Cities','PowerPlants');
            ss_loc_names = {ss_locs.ShortName};
            n_locs = numel(ss_locs);
            
            n_columns = numel(time_periods)*numel(days_of_week);
            values = nan(n_locs, n_columns);
            colnames = cell(1, n_columns);
            
            output_tables = make_empty_struct_from_cell(requested_values, values);
            
            
            i_column = 1;
            for i_time = 1:numel(time_periods)
                fprintf('Working on %s\n', time_periods{i_time});
                if regcmp(time_periods{i_time}, '2yr') && ~wrf_bool
                    loc_inds = 1:70;
                else
                    loc_inds = 1:71;
                end
                
                for i_dow = 1:numel(days_of_week)
                    fprintf('  Loading %s data\n', days_of_week{i_dow});
                    
                    [start_date, end_date] = misc_emissions_analysis.select_start_end_dates(time_periods{i_time});
                    Data = load(misc_emissions_analysis.fits_file_name(start_date, end_date, wrf_bool, loc_inds, days_of_week{i_dow}, 'lu'));
                    
                    for i_val = 1:numel(requested_values)
                        fprintf('  Computing %s\n', requested_values{i_val});
                        for i_loc = 1:numel(Data.locs)
                            this_loc = Data.locs(i_loc);
                            if isempty(this_loc.fit_info.emgfit)
                                fprintf('    Skipping %s because it looks like the fit didn''t work\n', this_loc.ShortName);
                                continue
                            end
                            loc_ind = strcmp(this_loc.ShortName, ss_loc_names);
                            
                            output_tables.(requested_values{i_val})(loc_ind, i_column) = quantity_fxns.(requested_values{i_val})(this_loc);
                        end
                    end
                    
                    colnames{i_column} = sprintf('%s_%s', time_periods{i_time}, days_of_week{i_dow});
                    i_column = i_column + 1;
                end
            end
            
            for i_val = 1:numel(requested_values)
                output_tables.(requested_values{i_val}) = array2table(output_tables.(requested_values{i_val}), 'RowNames', ss_loc_names, 'VariableNames', colnames);
            end
            
            function corr_val = calc_correlation(this_loc)
                % for now, just want correlation of a and x_0
                var1_ind = 1;
                var2_ind = 2;
                try
                    [~, corr_mat] = cov2corr(emg_cov_mat(this_loc.fit_info.fitresults.Hessian, this_loc.no2_sectors.x, this_loc.no2_sectors.linedens, this_loc.fit_info.emgfit));
                    corr_val =  corr_mat(var1_ind, var2_ind);
                catch err
                    if strcmpi(err.identifier, 'finance:cov2corr:invalidCovMatrixSymmetry')
                        fprintf('    Skipping %s due to problem calculating correlation matrix: "%s"\n', this_loc.ShortName, err.message);
                        corr_val = nan;
                    else
                        rethrow(err)
                    end
                end
            end
        end
        
        
        function bias_found = test_fit_for_bias(line_dens, emgfit, varargin)
            % TEST_FIT_FOR_BIAS(LINE_DENS, EMG_FIT) Test if a fit is biased
            % relative to its line density, meaning that it sits
            % consistently above or below.
            %
            % Parameters:
            %
            %   'window' - how wide a window to use (in # of points) for
            %   the test.
            %
            %   'confidence' - the confidence level for the bias test.
            %   Default is 0.95 i.e. 95%.
            p = advInputParser;
            p.addParameter('window', 10);
            p.addParameter('confidence', 0.95);
            
            p.parse(varargin{:})
            pout = p.Results;
            
            window = pout.window;
            confidence = pout.confidence;
            
            % tinv assumes a one-sided distribution, the two sided one has
            % half the alpha (1-p) value
            alpha = 1 - confidence;
            p = 1 - alpha/2;
            t_value = tinv(p, window);
            
            bias_found = false(size(line_dens));
            
            for i_start = 1:(numel(line_dens) - window + 1)
                i_end = i_start + window - 1;
                mean_diff = abs(nanmean(emgfit(i_start:i_end)) - nanmean(line_dens(i_start:i_end)));
                diff_crit = t_value * nanstd(line_dens(i_start:i_end)) / sqrt(window);
                if mean_diff > diff_crit
                    bias_found(i_start:i_end) = true;
                end
            end
        end
        
        function figs = plot_counties_around_loc(varargin)
            % PLOT_COUNTIES_AROUND_LOC() Plot county outlines and names
            % around the specified locations. Parameters:
            %
            %   'loc_inds' - see class help
            p = advInputParser;
            p.addParameter('loc_inds', []);
            p.parse(varargin{:});
            pout = p.Results;
            
            loc_inds = pout.loc_inds;
            if isempty(loc_inds)
                loc_inds = misc_emissions_analysis.get_loc_inds_interactive();
            end
            
            locs = misc_emissions_analysis.read_locs_file();
            locs = locs(loc_inds);
            figs = gobjects(size(locs));
            
            counties = misc_emissions_analysis.read_county_shapefile();
            
            for i_loc = 1:numel(locs)
                this_loc = locs(i_loc);
                loc_radius = max(locs.BoxSize(3:4));
                % Find all counties whose bounding box center is close to
                % the location
                xx_county = false(size(counties));
                for i_county = 1:numel(counties)
                    bb_center = nanmean(counties(i_county).BoundingBox, 1);
                    r = sqrt(sum((bb_center - [this_loc.Longitude, this_loc.Latitude]).^2));
                    xx_county(i_county) = r <= loc_radius*2;
                end
                
                figs(i_loc) = figure;
                line(this_loc.Longitude, this_loc.Latitude, 'linestyle', 'none', 'marker', 'x', 'markersize',16,'linewidth',2,'color','r');
                draw_circle(this_loc.Longitude, this_loc.Latitude, loc_radius, 'color', 'r');
                c_inds = find(xx_county);
                for i_county = 1:numel(c_inds)
                    this_county = counties(c_inds(i_county));
                    line(this_county.X, this_county.Y, 'color','k');
                    bb_center = nanmean(this_county.BoundingBox, 1);
                    text(bb_center(1), bb_center(2), this_county.NAME);
                end
                state_outlines('m');
                title(this_loc.ShortName);
            end
        end
        
        function figs = plot_vcd_diff_around_locs(loc_inds, years, varargin)
            % PLOT_VCD_DIFF_AROUND_LOCS(LOC_INDS, YEARS) Plot difference in
            % BEHR and WRF-Chem VCDs around a location. 
            p = inputParser;
            p.addParameter('only_diff', true);
            p.addParameter('diff_type', 'abs');
            p.parse(varargin{:});
            pout = p.Results;
            
            only_diff = pout.only_diff;
            diff_type = pout.diff_type;
            
            loc_inds = misc_emissions_analysis.convert_input_loc_inds(loc_inds);
            locs = misc_emissions_analysis.read_locs_file();
            locs = misc_emissions_analysis.cutdown_locs_by_index(locs, loc_inds);
            n_locs = numel(locs);
            
            [wrf_vcds, wrf_lon, wrf_lat] = misc_wrf_lifetime_analysis.compute_wrf_vcds_for_years(years, 'no2');
            behr = misc_emissions_analysis.load_vcds_for_years(years, 'TWRF');
            behr_vcds = behr.daily_vcds;
            behr_lon = behr.lon;
            behr_lat = behr.lat;
            
            figs = gobjects(n_locs,1);
            for i_loc = 1:n_locs
                this_loc = locs(i_loc);
                % get the BEHR VCDs w/i the box width of the city. Get the
                % WRF VCDs over a bit larger area and interpolate them to
                % the BEHR VCDs lat/lon
                radius = this_loc.BoxSize(3)/0.05; % the radius is the number of grid points, not distance.
                [xx,yy] = misc_emissions_analysis.find_indicies_in_box_around_point(this_loc, behr_lon, behr_lat, radius);
                these_behr_vcds = behr_vcds(xx,yy);
                these_behr_lon = behr_lon(xx,yy);
                these_behr_lat = behr_lat(xx,yy);
                
                xx_wrf = misc_emissions_analysis.find_indices_in_radius_around_loc(this_loc, wrf_lon, wrf_lat, radius*3);
                WI = scatteredInterpolant(wrf_lon(xx_wrf), wrf_lat(xx_wrf), wrf_vcds(xx_wrf));
                these_wrf_vcds = reshape(WI(these_behr_lon(:), these_behr_lat(:)), size(these_behr_vcds));
                
                figs(i_loc) = figure;
                if ~only_diff
                    figs(i_loc).Position(3) = 2 * figs(i_loc).Position(3);
                    ax=subplot(1,3,1);
                    pcolor_vcds(ax, these_behr_lon, these_behr_lat, these_behr_vcds, 'none');
                    title('BEHR');
                    
                    ax = subplot(1,3,2);
                    pcolor_vcds(ax, these_behr_lon, these_behr_lat, these_wrf_vcds, 'none');
                    title('WRF-Chem');
                    
                    ax = subplot(1,3,3);
                else
                    ax = axes();
                end
                
                switch lower(diff_type)
                    case 'abs'
                        this_diff = these_wrf_vcds - these_behr_vcds;
                    case 'rel'
                        this_diff = reldiff(these_wrf_vcds, these_behr_vcds)*100;
                    otherwise
                        error('diff type not recognized')
                end
                pcolor_vcds(ax, these_behr_lon, these_behr_lat, this_diff, diff_type);
                title(this_loc.Location);
            end
            
            function pcolor_vcds(ax,lon,lat,vcds,diff_type)
                pcolor(ax, lon, lat, vcds);
                shading flat;
                cb = colorbar;
                switch lower(diff_type)
                    case 'abs'
                        cb.Label.String = '\Delta VCD (molec. cm^{-2})';
                        colormap(ax, blue_red_cmap)
                        caxis(calc_plot_limits(vcds(:), 'diff', 'pow10'))
                    case 'rel'
                        cb.Label.String = '%\Delta VCD';
                        colormap(ax, blue_red_cmap)
                        caxis(calc_plot_limits(vcds(:), 'diff', 'pow10'))
                    case 'none'
                        cb.Label.String = 'VCD (molec. cm^{-2})';
                        caxis(calc_plot_limits(vcds(:), 'zero', 'pow10'))
                end
                state_outlines('k');
            end
        end
        
        function fig = plot_linedens_trends(varargin)
            %PLOT_LINEDENS_TRENDS Plot trends in line densities of cities
            %
            %   Parameters:
            %
            %   'x' - the x coordinates of the line density.
            %
            %   'ld_array' - the line density array loaded by LOAD_LINE_DENSITY_ARRAY.
            %   If not given then this and x are both loaded. If this is given, but x
            %   is not, the standard x is assumed.
            %
            %   'loc_inds' - location indices or names. If not given, all cities are
            %   plotted on one figure.
            %
            %   'normalize_to' - how to normalize the line densities. Options are:
            %       * false - do not normalize
            %       * 'mean-vec' - normalize by the vector of mean line densities, i.e.
            %       each point in the line density gets normalized by its mean.
            %       * 'mean' - normalize by the overall mean of the line densities,
            %       i.e. all points are normalized by the same value.
            %       * 'max-vec' - as 'mean-vec' but for the maximum
            %       * 'max' - as 'mean' but for the maximum
            %       * 'first' - normalize by the first year to have non-NaN line
            %       densities. Behaves like 'mean-vec' and 'max-vec'.
            %
            %   'average_cities' - average across all cities selected by 'loc_inds'.
            
            p = advInputParser;
            p.addParameter('x', -100:3:200);
            p.addParameter('ld_array', nan);
            p.addParameter('loc_inds', 1:49);
            p.addParameter('normalize_to', false);
            p.addParameter('average_cities', false);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            x = pout.x;
            ld_array = pout.ld_array;
            inds = misc_emissions_analysis.convert_input_loc_inds(pout.loc_inds);
            normalize_to = pout.normalize_to;
            do_average = pout.average_cities;
            
            if isscalar(ld_array)
                [x, ld_array] = misc_emissions_analysis.load_line_density_array();
            end
            
            ncities = numel(inds);
            years = 2006:2013;
            locs = misc_emissions_analysis.read_locs_file();
            
            if normalize_to
                vec_sz = [1, 1, numel(years)];
                point_sz = [1, numel(x), numel(years)];
                switch lower(normalize_to)
                    case 'mean-vec'
                        yr_lds = nanmean(ld_array, 3);
                        sz = vec_sz;
                        ystr = 'Norm. to mean vec';
                    case 'mean'
                        yr_lds = reshape(ld_array, size(ld_array,1), []);
                        yr_lds = nanmean(yr_lds, 2);
                        sz = point_sz;
                        ystr = 'Norm. to mean';
                    case 'max-vec'
                        yr_lds = nanmax(ld_array, [], 3);
                        sz = vec_sz;
                        ystr = 'Norm to max vec';
                    case 'max'
                        yr_lds = reshape(ld_array, size(ld_array,1), []);
                        yr_lds = nanmax(yr_lds, [], 2);
                        sz = point_sz;
                        ystr = 'Norm to max';
                    case 'first'
                        % If we're averaging, we want all cities relative
                        % to the same first year, otherwise that means
                        % we'll be averaging quantities that are relative
                        % to different years together. If we're not
                        % averaging, then let's make it relative to the
                        % first good year.
                        yr_lds = extract_first(ld_array, do_average);
                        sz = vec_sz;
                        ystr = 'Norm to first year';
                    otherwise
                        error('%s is not a valid value for NORMALIZE_TO', normalize_to)
                end
                yr_lds = repmat(yr_lds, sz);
                ld_array = ld_array ./ yr_lds;
            else
                ystr = 'mol/km';
            end
            
            if do_average
                ld_array = nanmean(ld_array(inds, :, :), 1);
                ncities = 1;
                inds = 1;
            end
            
            
            
            fig = figure;
            [height, width] = square_subplot_dims(ncities);
            for icity = 1:numel(inds)
                ax = subplot(height, width, icity);
                subld = squeeze(ld_array(inds(icity), :, :));
                for iyr = 1:size(subld,2)
                    if iyr == normalize_to
                        continue
                    end
                    col = map2colmap(iyr, 1, size(subld,2), 'jet');
                    line(ax, x, subld(:, iyr), 'color', col);
                end
                colorbar;
                colormap('jet');
                caxis([years(1), years(end)]);
                ylabel(sprintf('Line densities (%s)', ystr));
                if ~do_average
                    title(ax, locs(inds(icity)).Location);
                end
            end
            
            subplot_stretch(height, width, 'factor', 0.75);
            
            function first_lds = extract_first(lds, being_averaged)
                if being_averaged
                    first_lds = lds(:, :, 1);
                    return
                end
                has_data = squeeze(any(~isnan(lds),2));
                first_lds = nan(size(lds,1), size(lds,2));
                for i = 1:size(has_data,1)
                    ifirst = find(has_data(i,:),1,'first');
                    if ~isempty(ifirst)
                        first_lds(i,:) = lds(i,:,ifirst);
                    end
                end
            end
            
        end


        
        function figs = plot_line_dens_fits_by_year(varargin)
            % PLOT_LINE_DENS_FITS_BY_YEAR Plots line densities and their
            % fits from all years on one plot.
            %
            % Parameters:
            %
            %   'loc_inds' - see class help
            %
            %   'ynorm' - how to normalize the line densities and fits
            %   y-coordinates:
            %       * 'min': subtract the minimum value
            %       * 'max': subtract the maximum value
            %       * 'squeeze': normalize to the range [0, 1]
            %       * 'bckgnd-max': normalize by subtracted the fitted
            %       background then dividing by the maximum.
            %       * 'none': no normalization
            %
            %   'xnorm' - how to normalize the x-coordinates:
            %       * 'ldmax': set the x-coordinate of the maximum line
            %       density to 0
            %       * 'fitmax': set the x-coordinate of the maximum of the
            %       fit to 0
            %       * 'mu': make the x-coordinate relative to the mu
            %       fitting parameter
            %       * 'none': no normalization
            %
            %   'plot_ld' - boolean, whether to plot line densities.
            %
            %   'plot_fit' - boolean, whether to plot fits.
            %
            %   'source' - 'behr' or 'wrf', controls whether satellite
            %   ('behr') or model ('wrf') line densities are used.
            p = advInputParser;
            p.addParameter('loc_inds', 1:71);
            p.addParameter('ynorm', 'none'); % 'min', 'max', 'squeeze', 'bckgnd-max', or 'none'
            p.addParameter('xnorm', 'none'); % 'ldmax', 'fitmax', 'mu', or 'none'
            p.addParameter('plot_ld', true);
            p.addParameter('plot_fit', true);
            p.addParameter('source', 'behr');
            p.addParameter('include_bad', false);
            p.addParameter('include_weekends', true);
            p.addParameter('key_years_only', false);
            
            p.parse(varargin{:});
            pout = p.Results;
            
            locs = misc_emissions_analysis.read_locs_file();
            loc_inds = misc_emissions_analysis.convert_input_loc_inds(pout.loc_inds);
            locs = misc_emissions_analysis.cutdown_locs_by_index(locs, loc_inds);
            n_locs = numel(locs);
            
            ynorm_type = pout.ynorm;
            xnorm_type = pout.xnorm;
            plot_line_dens = pout.plot_ld;
            plot_fit = pout.plot_fit;
            data_source = pout.source;
            include_bad_fits = pout.include_bad;
            include_weekends = pout.include_weekends;
            key_years_only = pout.key_years_only;
            
            if strcmpi(data_source, 'behr')
                wrf_bool = false;
                weekdays = 'TWRF';
                n_subplots = 1 + include_weekends;
                ld_scale = 1;
            elseif strcmpi(data_source, 'wrf')
                wrf_bool = true;
                weekdays = 'UMTWRFS';
                n_subplots = 1;
                include_weekends = false;
                ld_scale = 1e5/6.022e23;
            else
                error('Data source "%s" not recognized', data_source);
            end
            
            years = 2006:2013;
            n_yrs = numel(years);
            xcoords = cell(n_locs, n_yrs, 2);
            line_densities = cell(n_locs, n_yrs, 2);
            fits = cell(n_locs, n_yrs, 2);
            
            for i_yr = 1:n_yrs
                yr = years(i_yr);
                fprintf('Loading %d\n', yr);
                sdate = sprintf('%04d-04-01', yr-1);
                edate = sprintf('%04d-09-30', yr+1);
                FitsTWRF = load(misc_emissions_analysis.fits_file_name(sdate, edate, wrf_bool, 1:71, weekdays, 'lu', 'no2_vcds'));
                if include_weekends
                    FitsUS = load(misc_emissions_analysis.fits_file_name(sdate, edate, wrf_bool, 1:71, 'US', 'lu', 'no2_vcds'));
                end
                
                for i_loc = 1:n_locs
                    xx = loc_inds(i_loc);
                    if include_bad_fits || misc_emissions_analysis.is_fit_good_by_loc(FitsTWRF.locs(xx), 'any_num_pts', true)
                        ld_twrf = normalize_y(FitsTWRF.locs(xx).no2_sectors.linedens*ld_scale, FitsTWRF.locs(xx));
                        fit_twrf = normalize_y(FitsTWRF.locs(xx).fit_info.emgfit, FitsTWRF.locs(xx));
                        x_twrf = normalize_x(FitsTWRF.locs(xx).no2_sectors.x, ld_twrf, fit_twrf, FitsTWRF.locs(xx));
                        xcoords{i_loc, i_yr, 1} = x_twrf;
                        line_densities{i_loc, i_yr, 1} = ld_twrf;
                        fits{i_loc, i_yr, 1} = fit_twrf;
                    else
                        xcoords{i_loc, i_yr, 1} = nan;
                        line_densities{i_loc, i_yr, 1} = nan;
                        fits{i_loc, i_yr, 1} = nan;
                    end
                    
                    if include_weekends && (include_bad_fits || misc_emissions_analysis.is_fit_good_by_loc(FitsUS.locs(xx), 'any_num_pts', true))
                        ld_us = normalize_y(FitsUS.locs(xx).no2_sectors.linedens*ld_scale, FitsUS.locs(xx));
                        fit_us = normalize_y(FitsUS.locs(xx).fit_info.emgfit, FitsUS.locs(xx));
                        x_us = normalize_x(FitsUS.locs(xx).no2_sectors.x, ld_us, fit_us, FitsUS.locs(xx));
                        xcoords{i_loc, i_yr, 2} = x_us;
                        line_densities{i_loc, i_yr, 2} = ld_us;
                        fits{i_loc, i_yr, 2} = fit_us;
                    else
                        xcoords{i_loc, i_yr, 2} = nan;
                        line_densities{i_loc, i_yr, 2} = nan;
                        fits{i_loc, i_yr, 2} = nan;
                    end
                end
            end
            
            
            figs = gobjects(n_locs, 1);
            for i_loc = 1:n_locs
                figs(i_loc) = figure;
                subplot_stretch(n_subplots,1);
                ax1 = subplot(n_subplots,1,1);
                
                key_years = cities_lifetime_groups.get_key_years(locs(i_loc).ShortName, 'TWRF', 'no_nans');
                plot_ld_fits(ax1, xcoords(i_loc, :, 1), line_densities(i_loc, :, 1), fits(i_loc, :, 1), key_years);
                set_axis_labels(ax1);
                title(ax1, sprintf('%s, weekdays', locs(i_loc).ShortName));
                
                if include_weekends
                    ax2 = subplot(n_subplots,1,2);
                    key_years = cities_lifetime_groups.get_key_years(locs(i_loc).ShortName, 'US', 'no_nans');
                    plot_ld_fits(ax2, xcoords(i_loc, :, 2), line_densities(i_loc, :, 2), fits(i_loc, :, 2), key_years);
                    set_axis_labels(ax2);
                    title(ax2, 'weekends');
                end
            end
            
            function x = normalize_x(x, ld, fit, loc)
                switch lower(xnorm_type)
                    case 'none'
                        % do nothing
                    case 'ldmax'
                        [~,idx] = max(ld);
                        x = x - x(idx);
                    case 'fitmax'
                        [~,idx] = max(fit);
                        x = x - x(idx);
                    case 'mu'
                        x = x - loc.fit_info.ffit.mu_x;
                    otherwise
                        error('No method defined for "xnorm" = "%s"', xnorm_type)
                end
            end
            
            function y = normalize_y(y, loc)
                switch lower(ynorm_type)
                    case 'none'
                        % do nothing
                    case 'min'
                        y = y - min(y(:));
                    case 'max'
                        y = y - max(y(:));
                    case 'squeeze'
                        y = scale_to_range(y, [0, 1]);
                    case 'bckgnd-max'
                        y = y - loc.fit_info.ffit.B;
                        y = y / max(y(:));
                    otherwise
                        error('No method implemented for "ynorm" = "%s"', ynorm_type);
                end
            end
            
            function set_axis_labels(ax)
                yvars = {};
                if plot_line_dens
                    yvars{end+1} = 'Line density';
                end
                if plot_fit
                    yvars{end+1} = 'Fit';
                end
                
                switch lower(ynorm_type)
                    case 'none'
                        y_normstr = '';
                    case 'min'
                        y_normstr = ', normalized to minimum';
                    case 'max'
                        y_normstr = ', normalized to maximum';
                    case 'squeeze'
                        y_normstr = ', normalized';
                    case 'bckgnd-max'
                        y_normstr = ', norm. background to max';
                    otherwise
                        y_normstr = ' ?';
                end
                
                ylabel(ax, sprintf('%s (mol/km%s)', strjoin(yvars, ' and '), y_normstr));
                
                switch lower(xnorm_type)
                    case 'none'
                        x_normstr = 'Distance from city center';
                    case 'ldmax'
                        x_normstr = 'Distance from line dens. max';
                    case 'fitmax'
                        x_normstr = 'Distance from fit max';
                    case 'mu'
                        x_normstr = 'Distance from \mu_x';
                    otherwise
                        x_normstr = '?';
                end
                xlabel(ax, sprintf('%s (km)', x_normstr));
            end
            
            function plot_ld_fits(ax, x, lds, fits, key_yrs)
                h_ld = gobjects(n_yrs,1);
                h_fit = gobjects(n_yrs,1);
                for i=1:numel(x)
                    if key_years_only && ~ismember(years(i), key_yrs)
                        continue
                    end
                    
                    if plot_line_dens
                        h_ld(i) = line(ax, x{i}, lds{i}, 'marker', 'o', 'linestyle', 'none');
                    end
                    if plot_fit
                        h_fit(i) = line(ax, x{i}, fits{i}, 'linewidth', 2);
                    end
                end
                
                if key_years_only
                    xx_yrs = ismember(years, key_yrs);
                    h_ld = h_ld(xx_yrs);
                    h_fit = h_fit(xx_yrs);
                    line_years = key_yrs;
                else
                    line_years = years;
                end
                
                % If only plotting fit or only plotting line densities, just plot
                % them and use those series in the legend. If plotting both, use
                % the fits in the legend for colors and add dummy entries to
                % differentiate fit and line density
                h = [];
                leg_strs = arrayfun(@(x) sprintf_ranges((x-1):(x+1)), line_years', 'uniform', false);
                if plot_fit
                    h = h_fit;
                    misc_emissions_analysis.set_year_series_plot_colors(h_fit, 'k', line_years);
                    if plot_line_dens
                        h(end+1) = line(ax, nan,nan,'linewidth',2,'color','k');
                        leg_strs{end+1} = 'Fits';
                    end
                end
                if plot_line_dens
                    if ~plot_fit
                        h = h_ld;
                    else
                        h(end+1) = line(ax, nan,nan,'marker','o','color','k','markerfacecolor','k','linestyle','none');
                        leg_strs{end+1} = 'Line densities';
                    end
                    misc_emissions_analysis.set_year_series_plot_colors(h_ld, 'k', line_years);
                end
                
                legend(ax, h, leg_strs);
            end
            
        end
        
        function plot_plume_diff(loc_ind_1, year1, loc_ind_2, year2, varargin)
            % PLOT_PLUME_DIFF( LOC_IND_1, YEAR1, LOC_IND_2, YEAR2 ) Plot
            % the difference in plume column densities between different
            % locations and/or years. LOC_IND_1 and LOC_IND_2 follow the
            % rules of LOC_INDS (see class help). YEAR1 and YEAR2 are the
            % center years of the 3-year windows.
            %
            % Parameters:
            %   'norm' - how to normalize the plumes before differencing.
            %   'none' (default) does not normalize, 'squeeze' normalizes
            %   to [0,1]
            %
            %   'dow' - days of week (see class help)
            p = advInputParser;
            p.addParameter('norm', 'none'); % 'none', 'squeeze'
            p.addParameter('dow', 'TWRF');
            p.parse(varargin{:});
            pout = p.Results;
            
            norm_type = pout.norm;
            days_of_week = pout.dow;
            
            loc_ind_1 = convert_loc_ind(loc_ind_1);
            loc_ind_2 = convert_loc_ind(loc_ind_2);
            
            locs1 = load_loc_for_year(year1);
            if year2 ~= year1
                locs2 = load_loc_for_year(year2);
            else
                locs2 = locs1;
            end
            
            loc1 = misc_emissions_analysis.cutdown_locs_by_index(locs1.locs, loc_ind_1);
            loc2 = misc_emissions_analysis.cutdown_locs_by_index(locs2.locs, loc_ind_2);
            clear locs1 locs2
            
            [no2_1, lon_1, lat_1] = get_data(loc1);
            [no2_2, lon_2, lat_2] = get_data(loc2);
            
            if ~isequal(size(no2_1), size(no2_2))
                error('NO2 arrays not the same size')
            elseif isequal(lon_1, lon_2) && isequal(lat_1, lat_2)
                x = lon_1;
                y = lat_1;
            else
                [x,y] = meshgrid(1:size(no2_1, 2), 1:size(no2_1, 1));
            end
            
            figure;
            no2_diff = no2_2 - no2_1;
            pcolor(x, y, no2_diff);
            caxis(calc_plot_limits(no2_diff(:), 'diff'));
            cb=colorbar;
            cb.Label.String = '\Delta NO_2 VCD (molec. cm^{-2})';
            colormap(blue_red_cmap);
            
            function loc_ind = convert_loc_ind(loc_ind)
                if ischar(loc_ind)
                    loc_ind = {loc_ind};
                end
                loc_ind = misc_emissions_analysis.convert_input_loc_inds(loc_ind);
            end
            
            function locs = load_loc_for_year(yr)
                sdate = sprintf('%04d-04-01', yr-1);
                edate = sprintf('%04d-09-30', yr+1);
                locs = load(misc_emissions_analysis.fits_file_name(sdate, edate, false, 1:71, days_of_week,'lu'));
            end
            
            function [no2, lon, lat] = get_data(loc)
                lon = loc.no2_sectors.lon;
                lat = loc.no2_sectors.lat;
                no2 = loc.no2_sectors.no2_mean;
                
                switch lower(norm_type)
                    case 'none'
                        % do nothing
                    case 'squeeze'
                        no2 = scale_to_range(no2, [0, 1]);
                end
            end
        end
        
        function fig = plot_background_ratio(varargin)
            % PLOT_BACKGROUND_RATIO() Plot the ratio of the peak NO2 line
            % density to the background.
            %
            % Parameters:
            %   'ratio' - how the city/background ratio is determined. Can
            %   be:
            %       * '#/#' e.g. 95/5 which specifies the percentiles of
            %       the "city" and "background". "background" will be taken
            %       from points upwind of the geographic center.
            %       * 'mu/#' e.g. 'mu/5' which means take the line density
            %       at mu_x as the city and the fifth percentile of points
            %       upwind of that as background.
            %       * 'a/B' means use the ratios of the a and B fitting
            %       parameters.
            %
            %   'days_of_week' - 'TWRF' or 'US'
            %
            %   'loc_inds' - vector or cell array specifying location to
            %   plot by their index in the standard locations struct or
            %   their short names.
            %
            %   'plot_type' - may be 'box' (box plot), 'ensemble' (plots
            %   individual cities) or 'ncdf' (save a netCDF file in the
            %   "Figures" folder in the top repo directory for use outside
            %   of Matlab).
            p = advInputParser;
            p.addParameter('loc_inds', 1:71);
            p.addParameter('days_of_week', 'TWRF');
            p.addParameter('ratio', '95/5');
            p.addParameter('plot_type', 'box'); % 'box', 'ensemble', or 'ncdf'
            p.parse(varargin{:});
            pout = p.Results;
            
            loc_inds = misc_emissions_analysis.convert_input_loc_inds(pout.loc_inds);
            days_of_week = pout.days_of_week;
            ratio_method = pout.ratio;
            plot_type = pout.plot_type;
            
            years = 2006:2013;
            
            % Parse the ratio input and plot method
            [city_ld_method, bckgnd_ld_method, do_check_fits, ylabel_str] = parse_ratio(ratio_method);
            [plot_method, extra_dat_method] = parse_plot(plot_type);
            
            ratios = nan(numel(loc_inds), numel(years));
            extra_data = ratios;
            for i_yr = 1:numel(years)
                yr = years(i_yr);
                yr_win = (yr-1):(yr+1);
                fprintf('Working on %s\n', sprintf_ranges(yr_win));
                
                fits = load(misc_emissions_analysis.behr_fit_file_name(yr_win, days_of_week));
                fits.locs = misc_emissions_analysis.cutdown_locs_by_index(fits.locs, loc_inds);
                
                for i_loc = 1:numel(loc_inds)
                    this_loc = fits.locs(i_loc);
                    if do_check_fits
                        if ~misc_emissions_analysis.is_fit_good_by_loc(this_loc)
                            continue
                        end
                    end
                    
                    city_val = city_ld_method(this_loc);
                    bckgnd_val = bckgnd_ld_method(this_loc);
                    ratios(i_loc, i_yr) = city_val / bckgnd_val;
                    extra_data(i_loc, i_yr) = extra_dat_method(this_loc);
                end
            end
            
            fig = figure;
            plot_method(years, ratios, extra_data);
            set(gca,'fontsize', 16);
            ylabel(ylabel_str);
            
            function [city_method, bckgnd_method, check_fit, ylabel_str] = parse_ratio(ratio_method)
                check_fit = true;
                if strcmpi(ratio_method, 'a/B')
                    city_method = @(loc) loc.fit_info.ffit.a;
                    bckgnd_method = @(loc) loc.fit_info.ffit.B;
                    ylabel_str = 'a/B';
                elseif regcmp(ratio_method, 'u/\d+')
                    percent = str2double(regexp(ratio_method, '\d+', 'match', 'once'));
                    city_method = @find_ld_at_mu;
                    bckgnd_method = @(loc) find_ld_at_percentile(loc, percent, loc.fit_info.ffit.mu_x);
                    ylabel_str = sprintf('LD(\\mu_x)/%dth percentile', percent);
                elseif regcmp(ratio_method, '\d+/\d+')
                    check_fit = false;
                    percents = cellfun(@str2double, strsplit(ratio_method, '/'));
                    city_method = @(loc) find_ld_at_percentile(loc, percents(1));
                    bckgnd_method = @(loc) find_ld_at_percentile(loc, percents(2), 0);
                    ylabel_str = sprintf('%dth/%dth percentiles', percents(1), percents(2));
                else
                    error('Ratio method "%s" not recognized', ratio_method);
                end
            end
            
            function [plot_method, second_data_method] = parse_plot(plot_in)
                second_data_method = @(loc) nan;
                switch lower(plot_in)
                    case 'box'
                        plot_method = @plot_box;
                    case 'ensemble'
                        plot_method = @plot_ensemble;
                        second_data_method = @get_nei_emis;
                    case 'ncdf'
                        plot_method = @save_ncdf_file;
                        second_data_method = @get_nei_emis;
                    otherwise
                        error('Plot type "%s" not recognized', plot_in);
                end
            end
            
            function ld = find_ld_at_mu(loc)
                ld = interp1(loc.no2_sectors.x, loc.no2_sectors.linedens, loc.fit_info.ffit.mu_x);
            end
            
            function ld = find_ld_at_percentile(loc, q, x_end)
                if nargin < 3
                    all_ld = loc.no2_sectors.linedens;
                else
                    xx = loc.no2_sectors.x <= x_end;
                    all_ld = loc.no2_sectors.linedens(xx);
                end
                ld = quantile(all_ld, q/100);
            end
            
            function plot_box(yrs, r, varargin)
                boxplot(r);
                set(gca, 'xtick', 1:numel(yrs), 'xticklabels', yrs);
            end
            
            function plot_ensemble(yrs, r, emis)
                yrs = repmat(yrs, size(r,1), 1);
                scatter(yrs(:), r(:), [], emis(:), 'filled');
                cb = colorbar;
                cb.Label.String = 'NEI Emissions (Mg NO/h)';
            end
            
            function save_ncdf_file(yrs, r, emis)
                n_yrs = numel(yrs);
                n_loc = size(r,1);
                nc_file = fullfile(misc_emissions_analysis.workspace_dir, '..', 'Figures', 'background_effect_data.nc');
                delete(nc_file);
                nccreate(nc_file, 'years', 'Dimensions', {'years', n_yrs}, 'Datatype', 'int32');
                nccreate(nc_file, 'location_inds', 'Dimensions', {'locations', n_loc}, 'Datatype', 'int32');
                nccreate(nc_file, 'ratios', 'Dimensions', {'locations', n_loc, 'years', n_yrs}, 'Datatype', 'double');
                nccreate(nc_file, 'nei_emis', 'Dimensions', {'locations', n_loc, 'years', n_yrs}, 'Datatype', 'double');
                ncwriteatt(nc_file, '/', 'ratio_method', ratio_method);
                ncwrite(nc_file, 'years', yrs);
                ncwrite(nc_file, 'location_inds', loc_inds);
                ncwrite(nc_file, 'ratios', r);
                ncwrite(nc_file, 'nei_emis', emis);
            end
            
            function e = get_nei_emis(loc)
                e = loc.emis_tau.nei_emis;
                if isempty(e)
                    e = nan;
                end
            end
        end


        %%%%%%%%%%%%%%%%
        % Plot helpers %
        %%%%%%%%%%%%%%%%
        
        function set_year_series_plot_colors(lineh, edge_color, line_years)
            n_lines = numel(lineh);
            
            if nargin < 2
                edge_color = '';
            end
            if nargin < 3
                line_years = 1:n_lines;
                min_yr = 1;
                max_yr = n_lines;
            else
                min_yr = 2006;
                max_yr = 2013;
            end
            
            for i=1:n_lines
                this_color = map2colmap(line_years(i), min_yr, max_yr, 'jet');
                lineh(i).Color = this_color;
                lineh(i).MarkerFaceColor = this_color;
                if ~isempty(edge_color)
                    lineh(i).MarkerEdgeColor = edge_color;
                end
            end
        end
    end
    
    methods(Static = true, Access = private)
        function width = get_window_width(width_in)
            width = opt_ask_number('What width of window to use (in years): 1 or 3?', width_in, '"window_width"', 'testfxn', @(x) isscalar(x) && (x==1 || x==3), 'testmsg', 'Must be 1 or 3');
        end
        
        function Profs = load_time_averaged_wrf_profs(time_period)
            [start_dates, end_dates] = misc_emissions_analysis.select_start_end_dates(time_period);
            prof_file = misc_emissions_analysis.wrf_avg_prof_file(start_dates, end_dates);
            Profs = load(prof_file);
            
            dvec = make_datevec(start_dates, end_dates);
            % My first run of average profiles added already weighted data
            % to a weighted average when combining the different workers,
            % so the weights were double counted. The weights in question
            % were the number of days averaged on each worker (I used 2
            % workers) so we need to divide by that to bring things back
            % into line.
            weight_correction = 1;%/(numel(dvec)/2);
            %warning('2018-07-16: Correcting average profiles for double-counting weights. For average profiles recalculated after 16 Jul 2018, this correction must be turned off');
            
            
            fns = fieldnames(Profs);
            for i_fn = 1:numel(fns)
                this_fn = fns{i_fn};
                if ismatrix(Profs.(this_fn))
                    % 2D arrays like lat and lon should not be rearranged
                    continue
                elseif ndims(Profs.(this_fn) == 3)
                    % Permute 3D arrays so that the first dimension is
                    % vertical, this will make it easier to subset them.
                    Profs.(this_fn) = permute(Profs.(this_fn), [3 1 2]) * weight_correction;
                else
                    E.notimplemented('Did not expect an array with ndims > 3')
                end
            end
        end
        
        function plot_map_series(ax, map_series, varargin)
            ax.NextPlot = 'add';
            for i=1:numel(map_series)
                % Default scatter size is 36. Double the point size for
                % legibility.
                scatter(ax, map_series(i).lon, map_series(i).lat, 72, map_series(i).change, map_series(i).symbol{:});
            end
            
            
            if ismember(varargin, 'include_names')
                % Put the name further out along the same vector from the
                % center as the point being plotted.
                point_lons = veccat(map_series.lon);
                point_lats = veccat(map_series.lat);
                center_lons = veccat(map_series.center_lon);
                center_lats = veccat(map_series.center_lat);
                dlon = point_lons - center_lons;
                dlat = point_lats - center_lats;
                names = veccat(map_series.names);
                % ensure all given as column vectors
                text(center_lons(:) + 1.5*dlon(:),center_lats(:)+1.5*dlat(:),names(:),'parent',ax);
            end
        end
        
        function difference_is_significant = is_change_significant(values, value_sds, value_dofs)
            % Calculate whether the difference is significant at the 95%
            % confidence level.
            
            difference_is_significant = false(size(values,1),1);
            for i_chng = 1:size(values,1)
                % The EMG fits have 5 fitting parameters.
                if any(isnan(values(i_chng,:))) || any(isnan(value_sds(i_chng,:))) || any(imag(value_sds(i_chng,:)) ~= 0) || any(isnan(value_dofs(i_chng,:)))
                    difference_is_significant(i_chng) = false;
                else
                    [~, ~, difference_is_significant(i_chng)] = two_sample_t_test(values(i_chng, 1), value_sds(i_chng, 1).^2 .* value_dofs(i_chng, 1), value_dofs(i_chng, 1) + 5,...
                        values(i_chng, 2), value_sds(i_chng, 2).^2 .* value_dofs(i_chng, 2), value_dofs(i_chng, 2) + 5,...
                        sum(value_dofs(i_chng,:)), 'confidence', 0.95);
                end
            end
        end
        
        function [difference_is_significant, t_calc_out, t_table_out] = is_change_significant_alt(values, value_sds, value_dofs)
            % IS_CHANGE_SIGNIFICANT_ALT( VALUES, VALUE_SDS, VALUE_DOFS )
            % Calculate if the changes in a set of values are significant.
            % VALUES, VALUE_SDS, and VALUE_DOFS are n-by-2 matrices of the
            % values, their standard deviations, and the number of degrees
            % of freedom in the fits. The first column is the inital
            % values, the second column the final. Returns an n-by-1
            % boolean vector indicating if the changes are significant.
            sz = [size(values,1), 1];
            difference_is_significant = false(sz);
            t_calc_out = nan(sz);
            t_table_out = nan(sz);
            for i_chng = 1:size(values,1)
                if any(isnan(values(i_chng,:))) || any(isnan(value_sds(i_chng,:))) || any(imag(value_sds(i_chng,:)) ~= 0) || any(isnan(value_dofs(i_chng,:)))
                    difference_is_significant(i_chng) = false;
                else
                    % assume five parameters are fit, so the number of
                    % measurements is the number of DoFs + 5.
                    %[~, ~, sig] = two_sample_t_test_alt(values(i_chng,1), value_sds(i_chng, 1), value_dofs(i_chng,1)+5,...
                    %    values(i_chng,2), value_sds(i_chng,2), value_dofs(i_chng,2)+5);
                    [t_calc, t_table, sig] = two_sample_t_test_alt(values(i_chng,1), value_sds(i_chng, 1), value_dofs(i_chng,1),...
                        values(i_chng,2), value_sds(i_chng,2), value_dofs(i_chng,2));
                    difference_is_significant(i_chng) = sig;
                    t_calc_out(i_chng) = t_calc;
                    t_table_out(i_chng) = t_table;
                end
            end
        end
        
        function plot_series = create_map_series(values, value_sds, value_dofs, value_r2, coords, corner, loc_names)
            % Helper function to set up the series with the right
            % coordinates and symbols based on their confidence and r2
            % values. "corner" should be a string indicating
            % which corner of the triangle in the plot it should be.
            % Possible values are "center", "top", "bottom-left", and
            % "bottom-right"
            
            E = JLLErrors;
            
            if ~exist('corner', 'var')
                corner = 'center';
            end
            
            % Go ahead and compute the offsets for the corner now
            offset_distance = 0.5; % the triangle's corners will be this distance from the center
            if isnumeric(corner)
                offset = offset_distance * [cosd(corner), sind(corner)];
            else
                switch lower(corner)
                    case 'center'
                        offset = [0 0];
                    case 'top'
                        offset = offset_distance * [cosd(90), sind(90)];
                    case 'bottom-left'
                        offset = offset_distance * [cosd(-150), sind(-150)];
                    case 'bottom-right'
                        offset = offset_distance * [cosd(-30), sind(-30)];
                    case 'bottom'
                        offset = offset_distance * [cosd(-90), sind(-90)];
                    otherwise
                        E.badinput('CORNER must be one of the strings "center", "top", "bottom, "bottom-left", or "bottom-right"');
                end
            end
            
            r2_criterion = 0.9;
            
            xx_bad_r2 = any(value_r2 < r2_criterion, 2);
            
            difference_is_significant = misc_emissions_analysis.is_change_significant(values, value_sds, value_dofs);
            
            xx_not_sig = ~difference_is_significant & ~xx_bad_r2;
            xx_sig = ~xx_not_sig & ~xx_bad_r2;
            
            xx_cell = {xx_sig, xx_not_sig, xx_bad_r2};
            
            default_mat = repmat({[]}, size(xx_cell));
            
            % Use cell arrays of cell arrays so that we can call
            % SCATTER(lon, lat, [], change, symbol{:}) and get filled
            % circles but not filled asterisks or x's. Testing shows that
            % calling 'filled' with * markers makes them just disappear.
            symbols = {{'o','filled'},{'*'},{'x'}};
            
            plot_series = struct('lon', default_mat, 'lat', default_mat, 'change', default_mat, 'percent_change', default_mat, 'symbol', symbols, 'names', {{}});
            for i_series = 1:numel(plot_series)
                plot_series(i_series).center_lon = coords.lon(xx_cell{i_series});
                plot_series(i_series).center_lat = coords.lat(xx_cell{i_series});
                plot_series(i_series).lon = coords.lon(xx_cell{i_series}) + offset(1);
                plot_series(i_series).lat = coords.lat(xx_cell{i_series}) + offset(2);
                
                % Take the difference and percent difference of the second
                % column of values minus the first.
                plot_series(i_series).change = diff(values(xx_cell{i_series},:),1,2);
                % reldiff(A,B) is (A-B)/B
                plot_series(i_series).percent_change = reldiff(values(xx_cell{i_series},2), values(xx_cell{i_series},1)) * 100;
                
                plot_series(i_series).names = loc_names(xx_cell{i_series});
            end
            
        end
        
        function dow = choose_days_of_week(varargin)
            E = JLLErrors;
            
            p = advInputParser;
            p.addOptional('days_of_week','',@ischar);
            p.addFlag('individual');
            
            p.parse(varargin{:});
            pout = p.AdvResults;
            
            days_of_week = pout.days_of_week;
            indiv_bool = pout.individual;
            
            if isempty(days_of_week)
                if indiv_bool
                    allowed_dow = {'S','M','T','W','R','F','S'};
                    dow = ask_multiselect('Choose days of week to include', allowed_dow);
                    dow = strjoin(dow, '');
                else
                    allowed_dow = {'weekdays', 'weekends', 'both'};
                    dow_ans = ask_multichoice('Choose days of week to include', allowed_dow, 'list', true);
                    switch lower(dow_ans)
                        case 'weekdays'
                            dow = 'TWRF';
                        case 'weekends'
                            dow = 'US';
                        case 'both'
                            dow = 'UMTWRFS';
                    end
                end
            elseif ~ischar(days_of_week) || any(~ismember(days_of_week, 'UMTWRFS'))
                E.badinput('DAYS_OF_WEEK must be a character array consisting only of the characters U, M, T, W, R, F, or S');
            else
                dow = days_of_week;
            end
        end
        
        function earth_area = calculate_total_omi_grid_area(lon, lat, resolution)
            E = JLLErrors;
            if numel(lon) ~= numel(lat)
                E.badinput('LON and LAT must have the same number of elements');
            end
            if ~isscalar(resolution) || ~isnumeric(resolution)
                E.badinput('RESOLUTION must be a scalar number');
            end
            
            earth_area = nan(size(lon));
            % The units of VCD are molec/cm^2, so we want area in cm^2.
            % WGS84 is the reference used in GPS systems.
            reference_ellip = referenceEllipsoid('wgs84','cm');
            for i_pt = 1:numel(lon)
                earth_area(i_pt) = areaquad(lat(i_pt)-resolution/2, lon(i_pt)-resolution/2, lat(i_pt)+resolution/2, lon(i_pt)+resolution/2, reference_ellip);
            end
        end
        
        function [xx,yy] = find_indices_box_by_loc_radius(location, radius, lon_grid, lat_grid )
            % Convenience wrapper around find_indicies_in_box_around_point
            % that converts a radius to a number of boxes.
            
            % Need to figure out the average grid spacing around the
            % location. Check each of the four cardinal directions and
            % average them.
            [pt_ind(1), pt_ind(2)] = misc_emissions_analysis.find_lat_lon_index(location.Longitude, location.Latitude, lon_grid, lat_grid);
            pt_moves = [-1 0; 1 0; 0 -1; 0 1];
            grid_del = nan(size(pt_moves,1),1);
            for i_pt = 1:size(pt_moves,1)
                i1 = pt_ind(1);
                j1 = pt_ind(2);
                i2 = pt_ind(1) + pt_moves(1);
                j2 = pt_ind(2) + pt_moves(2);
                grid_del(i_pt) = sqrt((lon_grid(i1,j1) - lon_grid(i2,j2)).^2 + (lat_grid(i1,j1) - lat_grid(i2,j2)).^2);
            end
            
            grid_del = nanmean(grid_del);
            n_cells = ceil(radius / grid_del);
            [xx, yy] = misc_emissions_analysis.find_indicies_in_box_around_point(location, lon_grid, lat_grid, n_cells);
        end
        
        function [xx,yy] = find_lat_lon_index(lon_pt, lat_pt, lon_grid, lat_grid)
            % Finds the index of the grid point closest to lon_pt and
            % lat_pt
            r = sqrt((lon_grid - lon_pt).^2 + (lat_grid - lat_pt).^2);
            [~, i_min] = min(r(:));
            [xx, yy] = ind2sub(size(lon_grid), i_min); 
        end
        
        function new_locs = match_locs_structs(new_locs, base_locs)
            % Cut down NEW_LOCS to have the same locations as BASE_LOCS
            E = JLLErrors;
            new_loc_names = {new_locs.Location};
            base_loc_names = {base_locs.Location};
            xx = ismember(new_loc_names, base_loc_names);
            new_locs(~xx) = [];
            check_loc_names = {new_locs.Location};
            if numel(check_loc_names) ~= numel(base_loc_names)
                E.callError('locs_not_available', 'One or more locations in BASE_LOCS were not present in NEW_LOCS');
            elseif any(~strcmp(check_loc_names, base_loc_names))
                E.callError('locs_not_matched', 'Trouble matching the cutdown NEW_LOCS to BASE_LOCS, the locations may be out of order');
            end
        end
        
        function loc_inds = loc_types_to_inds(varargin)
            locs = misc_emissions_analysis.read_locs_file();
            loc_inds = false(size(locs));
            for i_loc = 1:numel(locs)
                loc_inds(i_loc) = ismember(locs(i_loc).SiteType, varargin);
            end
            loc_inds = find(loc_inds);
        end
        
        function loc_inds = loc_names_to_inds(varargin)
            E = JLLErrors;
            loc_inds = nan(size(varargin));
            locs = misc_emissions_analysis.read_locs_file();
            short_names = {locs.ShortName};
            names = {locs.Location};
            for i_loc = 1:numel(varargin)
                this_ind = find(strcmpi(short_names, varargin{i_loc}) | strcmpi(names, varargin{i_loc}));
                if numel(this_ind) ~= 1
                    E.callError('loc_not_found', 'Could not find location index corresponding to "%s"', varargin{i_loc});
                end
                loc_inds(i_loc) = this_ind;
            end
        end
        
        function locs = append_new_spreadsheet_fields(locs)
            % If I have added new values to the spreadsheet since the last
            % time a particular step was run, this will ensure those values
            % are includes in the locations structure given as input.
            spreadsheet_locs = misc_emissions_analysis.read_locs_file();
            spreadsheet_locs = misc_emissions_analysis.match_locs_structs(spreadsheet_locs, locs);
            locs = copy_structure_fields(spreadsheet_locs, locs, 'missing');
        end
        
        
        function [is_sectors_vec, is_filtered_vec, is_weighted_vec, winds_strings, is_wrf_vec, days_of_week] = extract_info_from_file_names(files)
            E = JLLErrors;
            if ~ischar(files) && ~iscellstr(files)
                E.badinput('FILES must be a char array or cell array of such');
            end
            is_sectors_vec = regcmp(files, 'sectors');
            is_filtered_vec = ~regcmp(files, 'unfiltered'); % have to use not here b/c regcmp(files, 'filtered') would match unfiltered as well
            is_weighted_vec = ~regcmp(files, 'unweighted');
            winds_strings = regexp(files, 'winds-(lt|gt)\d', 'match', 'once');
            is_wrf_vec = regcmp(files, '^WRF');
            days_of_week = regexp(files, '(?<=_)[UMTWRFS]+(?=\.mat)', 'match', 'once');
        end
        
        function [use_wrf, loc_inds, wind_rej_field, file_loc_inds] = ask_to_use_wrf(use_wrf, default_loc_inds, default_file_inds)
            if nargin < 1 || isnan(use_wrf)
                use_wrf = ask_yn('Use WRF line densities? (BEHR if no)');
            end
            
            if ~exist('default_loc_inds', 'var') || isempty(default_loc_inds)
                default_loc_inds = 1:71;
            end
            if ~exist('default_file_inds', 'var') || isempty(default_file_inds)
                default_file_inds = default_loc_inds;
            end
            
            if use_wrf
                loc_inds = default_loc_inds(ismember(default_loc_inds, 1:71));
                wind_rej_field = misc_emissions_analysis.wind_reject_field_wrf;
                file_loc_inds = 1:71;
            else
                loc_inds = default_loc_inds;
                file_loc_inds = default_file_inds;
                wind_rej_field = misc_emissions_analysis.wind_reject_field_std;
            end
            
        end
        
        function [wind_op, wind_speed] = choose_wind_criteria(wind_op, wind_speed)
            E = JLLErrors;
            
            allowed_wind_ops = {'lt','gt'};
            wind_op_names = {'less than', 'greater than'};
            if isempty(wind_op)
                i_op = ask_multichoice('Use winds that are what vs the criteria?', wind_op_names, 'list', true, 'index', true);
                wind_op = allowed_wind_ops{i_op};
            elseif ~ismember(wind_op, allowed_wind_ops)
                E.badinput('WIND_OP must be one of %s', strjoin(allowed_wind_ops, ', '));
            end
            
            if isempty(wind_speed)
                wind_speed = ask_number('Enter the wind speed criterion in m/s', 'testfxn', @(x) isscalar(x) && x >= 0, 'testmsg', 'Enter a scalar positive number');
            elseif ~isscalar(wind_speed) || ~isnumeric(wind_speed)
                E.badinput('WIND_SPEED must be a scalar number >= 0');
            end
        end
        
    end
    
end
